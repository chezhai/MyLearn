___this file is for learning c language___    

# C基本知识
###  1.  指针   
1.  [指针初级](https://zhuanlan.zhihu.com/p/93449463)   
2.  [指针高级](https://zhuanlan.zhihu.com/p/94518185)   
3.  [void指针](https://www.cnblogs.com/wuyudong/p/c-void-point.html)    
    <span id="jump1">~~jump there~~</span>
4.  [引用和指针](http://irootlee.com/juicer_pointer_reference/)   
5.  常量指针和指针常量    
6.  函数名即是函数首地址，可以是用&   

> 常量指针(const int\*): 该指针指向的那个变量是不可被修改的；但它本身的指向可以被修改。  
> 指针常量(int \*const 或者 int const\*): 该指针指向的变量是可以被修改的；但它本身的指向是不能被修改的。     

7.  [const, volatile同时修饰同一个变量](https://blog.csdn.net/ShenJu_DL_ShengHuo/article/details/48241217)      

###   2.  浮点数表示方式   
1.  [float存储方式](http://blog.sina.com.cn/s/blog_973657a00102x2do.html) 
2.  [小数表示](https://blog.csdn.net/github_33873969/article/details/78040129)   
3.  为什么8bit限制是-128到127而不是-127到128?   
    -128~127是补码表示，而不是原码表示。  
    这个东西和原码、反码、补码的意义有关。  
    先介绍几个概念。  
    机器数：一个数在计算机中的二进制表示形式，带符号，最高位是符号位，正数为0，负数为1真值：  
    因为机器数带符号，直接按照二进制转换的话，得到的数值不一定是存储的真正的数值，所以机器数表示的实际的那个值，叫真值，例如1000 0001的真值 = –000 0001 = –1。  
    原码：符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。对于8bit数，其取值范围是:[1111 1111 , 0111 1111]，也就是[-127 , 127]，这个被叫做人脑最容易理解和计算的表示法。  
    反码：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。    
    补码：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1。(即在反码的基础上 +1)。注意，反码和补码基本无法直接看出数值，一般要转换为原码然后再计算其数值。上面提到了原码、反码以及补码三种数的编码方式，对于整数，这三种编码方式的结果都是一样的。但是对于负数其三码都是不同的，那么麻烦的反码和补码是干嘛的？  
    先想一下你在脑子里怎么算原码，人脑可以根据符号位，选择对真值的加减等处理，但是计算机不行，至少目前不行。计算机进行运算的时候，让计算机来辨别符号位，是一件效率非常低并且非常麻烦的事情，所以大牛们搞出了让符号位也参与运算的方式，减掉一个数等于加上这个数的负数，所以设计计算机时，可以只有加法，这样设计会简单一点。    
    如果直接是原码来参与，会出现如下结果：    
    ```
    1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
    ```
    这结果显然是不对的，所以出现了反码，使用反码参与计算时：    
    ```
    1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
    ```
    计算结果的真值是没问题的，但是对于结果0，对于实际的运算，+0和-0是一样的东西（数学中，对于极限等证明时，会区分+/-0），0带符号没啥意义，而且这样会出现[0000 0000]原 和 [1000 0000]原 两个编码分别表示了+0和-0，用2个编码保存一样的数非常浪费。所以再搞个补码：    
    ```
    1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
    ```
    这个时候，0可以用[0000 0000]表示，-0就没了。然后这个[1000 0000]这个数呢，就表示-128了，为什么，因为`-128 = -127-1 = [1000 0001]补 - [0000 0001]补 = 1000 0000`所以，使用补码表示时，解决了有符号数中+0和-0的问题，并且还可以多保存一个最小值。当然，如果以后计算体系发生翻天覆地的变化，也说不定会有其他的表示，只是现在的我们可能想象不到。因此，使用原码和反码表示时，是无法出来-128的，现代计算机对于有符号数，都是采用补码表示，所以8bit范围是-128~127,其他有符号的数也同理。  
    4.  [C++ 除法 四舍五入](https://blog.csdn.net/sinat_28442665/article/details/83819699)    
    5.  [逻辑左移、逻辑右移、算术左移、算术右移、循环左移、循环右移](https://blog.csdn.net/u011070169/article/details/53894154)   

###  [3.  VLA](https://www.cnblogs.com/Suzzz/p/4117431.html)   

###  4.  结构体  
1.  [结构体初始化](https://www.cnblogs.com/clover-toeic/p/3737189.html)   
    1.  [结构体变量定义](https://www.runoob.com/cprogramming/c-structures.html)       
    2.  [特定初始化，就是成员变量加了个"."](https://blog.csdn.net/comwise/article/details/9087279)   
2.  [结构体对齐规则]    
    1.  首个数据成员的地址（首地址）是0     
    2.  其他数据成员的首地址必须是该数据成员大小的整数倍    
    3.  结构体的总大小，为其成员中所含最大类型的正数倍      
    如果使用#pragma pack(N):    
    第二条中就要改为：其他数据成员的首地址必须是min(N, 该数据成员的大小)的整数倍    
3.  [union大小]   
    1.  所有成员中，最大长度的值是union的大小。比如说是N    
    2.  如过N不能够被其他数据成员的大小整除，比如说数据成员m不能被N整除。则取sizeof(m) * x = M，其中M>N。当然x不能是任意值，必须是第一次让M大于N的值   

###  #/##   
1.  #   
    在使用#define 定义宏中，可使用操作符#在字符串中输出实参，如下:    
    [#](../pictures/4.jpg "#")    
2.  ##  
    操作符## 也可以使用在带参数宏中替换部分内容，该操作符将宏中的两部分连接成一个内容， 比如：（咱不知道如何表示字符串，虽然连接起来是字符串，但是 C 语言中，表示字符串是用“”表示的，但是连接后没有双引号）   
    [##](../pictures/5.jpg "##")    
3.  [#define目前所知最全的](http://c.biancheng.net/view/446.html)     

5.  内建变量  
    1.  [\_\_func\_\_](https://blog.csdn.net/u011308691/article/details/45015613)     
        1.  在结构体的构造函数中，初始化成员列表使用`__func__`是可行的，其效果跟在函数中是用一样，不过将`__func__`标识符作为函数参数的默认值是不允许的：    
            ```
            void func_fail(std::string func_name = __func__) {} //无法通过编译
            ```
            这是因为在参数声明的时候，`__func`还没有被定义.   
    2.  [__VA_ARGS__， \_\_FILE\_\_， \_\_FUNCTION\_\_](https://blog.csdn.net/yiya1989/article/details/7849588)   
    3.  [\_\_COUNTER\_\_](https://zhuanlan.zhihu.com/p/64479211)    

###  奇技淫巧  
1.  [do...while(false)](https://blog.csdn.net/this_capslock/article/details/41843371)   
2.  快速范围判断  
    ```
    // 经常要批量判断某些值在不在范围内，如果int检测是[0, N)的话： 
    if (x >= 0 && x < N) ... // 原来是这样的
    if (((unsigned int)x) < N) ... //现在是这样的

    // 如果int检测的范围是[minx, maxx]的话：    
    if (x >= minx && x <= maxx) ... // 原来是这样的
    if (((x - minx) | (maxx - x)) >=0 ) ... // 现在是这样的
    上述中，第一个(x - minx)如果x < minx的话，得到的结果，是<0，高位是1，第二个判断同理，如果超过范围，高位也是1，两个条件进行比特或运算以后，只有两个高位都为0，最终才为真，同理：   
    if (((x - minx) | (maxx - x) | (y - miny) | (maxy - y)) >= 0) ... // 这样本来需要对[x, y]进行四次判断，这样完全可以并为一次判断，减少分支
    ```
3.  对于循环展开：    
    ```
    #define CPU_LOOP_UNROLL_4X(actionx1, actionx2, actionx4, width) do { \
      unsigned long __width = (unsigned long)(width); \
      unsigned long __increment = __width >> 2; \
      for (; __increment > 0; --__increment) { actionx4; } \
      if (__width & 2) { actionx2; } \
      if (__width & 1) { actionx1; } \
    } while(0);
    ```
4.  快速除以255   
    整数快速除以255很常见，例如图像绘制、合成、音频处理、混音计算：   
    ```
    #define div_255_fast(x) (((x) + (((x) + 257) >> 8)) >> 8)
    ```
    当x属于[0, 65536]范围内，该方法的误差为0.   
    进一步的可以是用SIMD：    
    ```
    // (x + ((x + 257) >> 8)) >> 8
    static inline __m128i _mm_fast_div_255_epu16(__m128i x) {
      return __m_srli_epi16(_mm_adds_epu16(x,
             __mm_srli_epi16(_mm_adds_epu16(x, _mm_set1_epi16(0x0101)), 8)), 8);
    }
    ```
    这样可以同时对8，对16bit的整数进行/255运算，照葫芦画瓢，还可以改出一个/65536，或者/32767版本。  
    对于任意大于0的整数，下面的方法x86一般，x64位还行：   
    ```
    static inline int32_t fast_div_255_any (int32_t n) {
      int32_t M = -2139062143;
      int64_t t = (int64_t)M * (int64_t)n;
      int32_t q = ((t >> 32) + n) >> 7;
      
      return q + (n >> 31);
    }
    ```
    因此如果整数范围属于[0,65536]推荐是用第一个版本，而任意大于0 的整数，推荐是用第二个版本。   

5.  常数范围裁剪    
    ```
    // 有时候你计算一个整数数值需要控制在0-255范围内，如果小于0，那么等于0， 如果大于255，那么等于255，做一个裁剪工作，可以是用如下位运算：   
    static inline int32_t clamp_to_o(int32_t x) {
      reutnr ((-x) >> 31) & x;
    }
    static inline int32_t clamp_to_255(int32_t x) {
      return (((255 - x) >> 31) | x) & 255;
    }
    // 这种方法可以裁剪任何2^n-1的常数，比如裁剪65535：   
    static inline int32_t clamp_to_65535 (int32_t x) {
      return (((655535 - x) >> 31) | x) & 65535;
    }
    ```
6.  [C语言一些常见的错误](http://www.gowrikumar.com/c/index.php)    
7.  [bit位构成的一些trick](http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel)    
