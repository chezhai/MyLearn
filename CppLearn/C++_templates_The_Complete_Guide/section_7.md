#  第七章 模板术语

1.  "类模板"还是"模板类"    
    目前的称呼仍然存在一些混淆：一般情况下类模板说明的该类是一个模板，它代表整个类家族的参数化描述。
    模板类通常被用于下面几个方面：  
    +  作为类模板的同义词     
    +  从模板产生的类     
    +  具有一个template-id名称的类    
    第二个含义和第三个含义区别是细微的，本书不做区分。      

2.  实例化和特化      
    1.  模板实例化是一个通过使用具体值替换模板实参，从模板产生出普通类、函数或者成员函数的过程。这个过程最后或得的实体(譬如类、函数、成员函数等等)就是我们说的特化。    
    2.  在C++中，实例化过程并不是产生特化的唯一方式。可以使用其他几只来显式地制定某个声明，该声明对模板参数进行特定的替换，从而产生特化：    

    ```
    template <typename T1, typename T2> //基本的类模板
    class MyClass{

    ...

    };

    template <>
    class MyClass { //显式特化

    ...

    };


    template <typename T1, typename T2>
    class MyClass<bool, T2> {

    ...

    };
    ```

    当谈及（显式或者隐式）特化的时候，普通模板被称为基本模板。基本模板的定义就是，如果模板声明的是一个普通生命，就成它生命的是一个基本模板。这类模板是指灭有在模板名称后面添加一对尖括号(和里面实参)的声明。    

3.  一处定义原则(ODR)   
    1.  和全局变量与静态数据成员一样，在整个程序中，非内联函数和成员函数只能被定义一次。    
    2.  类类型和内联函数在每个翻译单元中最多只能被定义一次，如果存在多个翻译单元，则其所有的定义都必须是等同的。一个翻译单元是指：预处理一个源文件所获得的结果，就是说它包括#include指示符所包含的内容。    

4.  模板实参和模板参数    
    1.  例子:   

        ```
        template <typename T, int, N>
        class ArrayClass {
        public:
          T array[N];
        };

        // 另一个功能相似的普通类
        class DoubleArrayInClass {
        public: double array[10];
        };
        ```

        如果我们使用double和10分别替换参数T和N，那么这两者本质上是相同的。在C++中，我们把这种替换后的名称表示为：`ArrrayInClass<double, 10>`。紧邻在模板名称ArrayInClass后面的是用一对尖括号包围起来的模板实参列表。
    2.  template-id(它是指紧随其后的尖括号内部的所有实参的组合)   
        1.  模板参数是指位于模板生命或者定义内部，关键字template后面所列举的名称（譬如我们例子中的T和N）。    
        2.  模板实参是指用来替换模板参数的各个对象（我们例子中的double和10）。和模板参数不同的是，模板实参可以有不局限于“标识符名称”（就是有多重类型或者值）。    
        3.  如果使用template-id进行替换，我们就称这种模板实参取代模板参数的替换为显式替换，但还存在有些情况会发生隐式替换（如果用缺省实参来替换模板参数）。    
        4.  一个基本原则是：模板实参必须是一个可以在便一起建确定的模板实体或者值。这个要求有助于减少模板实体的运行期开销。
        5.  因为模板参数是编译期实体，所以用他们来生成有效的模板实参：    

        ```
        template <typename T>
        class Dozen {
        public:
          ArrayInClass<T, 12> contents;
        };
        ```
        在上面的例子中，T及时一个模板参数（第一个T），也是一个模板实参（第二个T）。因此存在一种从简单模板构造出复杂模板的机制。    
