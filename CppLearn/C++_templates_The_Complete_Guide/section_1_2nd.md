#  第一章 函数模板      
###  初识模板   
1.  模板参数按照如下语法声明：      
    ```
    template <由逗号分割的模板参数>
    ```
    上面的声明中:     
    1.  模板参数是`typename T`。    
    2.  "<"，">"被称为尖括号。    
    3.  关键字typename标识了一个类型参数。    
    4.  T是类型参数。   
        1.  可以是用任意标识作为类型参数名，但是习惯上是用T。   
        2.  类型参数可以表示任意类型。    
        3.  它在模板被调用的时候确定。    
        4.  T指定的类型可以为基础类型，类或者其他类型，应该但是这些类型必须支持模板中用到的运算符。如下，T必须支持小于号。为了支持返回值，T还应该是_可拷贝的_     
            ```
            template <typename T>
            T max(T a, T b)
            {
              return b < a ? a : b;
            }
            ```
    5.  由于历史原因，typename还可以是用class表示，但不建议这么做。   
2.  模板使用      
    demo:   
    ```
    #include "max1.hpp"
    #include <iostream>
    #include <string>

    int main()
    {
      int i = 42;
      std::cout << "max(7, i): " << ::max(7, 9) << "\n";
      double f1 = 3.4;
      double f2 = -6.7;
      std::cout << "max(f1, f2): " << ::max(f1, f2) << "\n";
      std::string s1 = "mathematics";
      std::string s2 = "math";
      std::cout << "max(s1, s2): " << ::max(s1, s2) << "\n";
    }
    ```
    输出结果：    
    ```
    max(7, i): 42
    max(f1, f2): 3.4
    max(s1, s2): mathematics
    ```
    针对上述代码分析：    
    1.  作用域限制符：`::`    
    2.  上述是用作用域限制符会在全局作用域中查找max()模板。   
    3.  在编译阶段，模板并不是被编译成一个可以支持多个类型的实体，而是对每一个是用该模板的类型都会产生一个独立的实体。在本例子中，max()会被编译除三个实体，因为它被用于三种类型。      
    4.  实例化：    
        ```
        // 如果这样使用
        int i = 42;
        max(7, i);

        // 函数模板的类型参数是int，因此语义上等效于调用了如下函数
        int max(int a, int b)
        {
          return b < a ? a : b;
        }
        ```
        用具体类型取代模板类型参数的过程-----叫做”实例化“。它会产生模板的一个实例。     
    5.  只要结果是有意义的，即便是void作为模板参数也是有效的。    
        ```
        template <typename T>
        T foo (T*) {}

        void* vp = nullptr;
        foo(vp); // OK: 模板参数被推断为void
        foo(void*)
        ```
3.  两阶段编译检查    
    1.  在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误：    
        ```
        std::complex<float> c1, c2; // std::complex<>没有提供小于运算符
        ::max(c1, c2); // 编译期ERROR
        ```
        但是在定义的地方并没有遇到错误提示。    
    2.  模板是被分成两步编译的：    
        1.  在模板定义阶段，模板的检查并不包含类型参数的检查，只包含下面几个方面：    
            1.  语法检查。比如说少了分号。    
            2.  是用了未定义的不依赖于模板参数的名称（类型名，函数名，...）。   
            3.  为使用模板参数的static assertions.      
        2.  在模板实例化阶段，为确保所有代码都是有效的，模板会再次检查，尤其是哪些以来与类型参数的部分。比如：     
            ```
            template <typename T>
            void foo(T t)
            {
              undeclared(); // 如果undeclared()未定义，第一阶段就会报错，因为与模板参数无关
              undeclared(t); // 如果undeclared()未定义，第二阶段会报错，因为与模板参数有关

              static_assert(sizeof(int) > 10, "int too small"); // 与模板参数无关，总是报错
              static_assert(sizeof(T) > 10, "T too small"); // 与模板参数有关，只会在第二阶段报错
            }
            ```
        3.  两阶段编译检查会给模板带来一个问题：当实例化一个模板的时候，编译器需要看到模板的完整定义。这不同与函数编译和链接分离的思想，函数在编译阶段只需要声明就够了。我们这里是用以恶搞简单的办法：将模板的实现写在头文件中。    
###  模板参数推断     
1.  auto的推导参考modern C++      
2.  在类型推断中的类型转换    
    1.  在类型推断的时候自动的类型转换是受限制的。      
        1.  如果调用参数是按照引用传递的，任何类型转换都是不被允许的。通过模板类型参数T定义的两个参数，他们的实参的类型必须完全一样。   
        2.  如果调用参数是按值传递的，那么只有退化（decay）这一类简单的转换是被允许的：const/volatile限制符会被忽略，引用转换会被转换为被引用类型，raw array和函数被转换成相应的指针类型，通过模板类型参数T定义的两个参数，他们实参的类型在退化后必须一样。eg:    
            ```
            template <typename T>
            T max(T a, T b);

            // ...

            max(4, 7.2); // ERROR: 不确定T应该被腿短为int还是double
            std::string s;
            foo("hello", s); 不确定T应该被推断为const[6]还是std::string
            ```
            三种方法解决以上问题：    
            1.  对参数做类型转换    
                ```
                max(static_cast<double>(4), 7.2);
                ```
            2.  显示指定类型参数T的类型，这样编译器就不会再做类型推导。   
                ```
                max<double>(4, 7.2);
                ```
            3.  指明调用参数可能有不同的类型（多个模板参数）    

