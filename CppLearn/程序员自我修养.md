1.  温故而知新

    1.  本书解决的问题

2.  程序为什么要被编译器编译了之后才可以运行？

3.  编译器在把C语言程序转换成可以执行的机器码的过程中做了什么，怎么做的？

4.  最后编译出来的可执行文件里面是什么？除了机器码还有什么？他们是怎么存放的？怎么组织的？

5.  \#include
    \<stdio.h\>是什么意思？把stdio.h包含进来意味着什么？C语言库又是什么？它是怎么实现的？

6.  不同编译器（Microsoft
    VC，GCC）和不同的硬件平台（x86、SPARC、MIPS、ARM），以及不同的操作系统（Windows、Linux、Unix、Solaris）最终编译的结果一样吗？为什么？

7.  Hello
    World程序是怎么运行起来的？操作系统是怎么装载它的？它从哪儿开始执行？到哪结束？main函数之前发生了什么？main函数结束后发生了什么？

8.  如果没有操作系统，Hello
    World可以运行吗？如果要在一台没有操作系统的机器上运行Hello
    World需要什么？应该怎么实现？

9.  printf是怎么实现的？他为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？

10. Hello World程序在运行时，他在内存中是什么样子的？

    1.  万变不离其宗

11. 计算机多如牛毛的硬件设备中，有三个部件最为关键：CPU、内存、I/O控制芯片

12. 早起计算机没有很复杂的图形功能，CPU的核心频率不高，跟内存的频率一样，都是直接连接在同一总线上。后来CPU核心频率提升，内存跟不上CPU的速度，于是产生了与内存频率一致的系统总线，CPU采用倍频的方式与系统总线进行通信

13. 为了协调CPU、内存和高速的图形设备，人们设计了一个高速的北桥芯片，以便他们之间高速地交换数据。由于北桥运行速度高，如果相对低速的设备连接在北桥上，会非常复杂，所以20世纪90年代在系统总线上采用PCI结构，低速设备采用ISA，结构如下图所示：

14. SMP和多核：

在频率上短期内已经没有提高的余地了，于是人们就开始增加CPU的数量。

对称多处理器（SMP，Symmetrical
MultiProcessing，简单地讲就是每个CPU在系统中所处的地位和所发挥的功能都是一样的，是相互对称的，理论上讲，增加CPU的数量可以提升运算速度，但实际并不是这样：一个女人10个月可以生一个孩子，但10个女人1个月，并不能生一个孩子

站得高，望的远
--------------

1.  系统软件可以分为两块，一块是平台性的，比如操作系统内核、驱动程序、运行库和系统工具；另一块是用于程序开发的，比如编译器、汇编器、链接器等开发工具和开发库

2.  计算机系统软件体系结构采用一种层结构，一句名言：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决

3.  系统软件体系结构：

4.  每个层次之间都需要相互通信，既然通信就需要一个通信协议，我们一般称其为接口

5.  操作系统内核曾对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口定义决定了操作系统内核，具体来讲就是驱动程序如何操作硬件，如何与硬件进行通信。这种借口被称为硬件规格（Hardware
    Specification），它由生产厂商负责提供，操作系统和驱动程序的开发者通过于都硬件规格文档所规定的各种硬件编程接口标准来编写操作系统和驱动程序

    1.  操作系统做什么

6.  操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源

    1.  不要让CPU打盹

7.  计算机发展早期，如果一个CPU只能运行一个程序，CPU就闲下来了，于是人们编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待的CPU资源的程序启动，使CPU被充分利用，这被称为多道程序（Multiprogramming）

8.  对于多道程序来说，程序之间不分轻重缓急，如果有些程序急需使用CPU来完成一些任务（比如用户交互），那么很有可能很长时间后才有机会分配到CPU

9.  经过稍微改进，程序运行模式变成了一种协作的模式，即每个程序运行一段时间以后都主动让出CPU给其他程序，是得一段时间内每个程序都有机会运行一小段时间，这种程序协作模式叫做分时系统（Time-Sharing
    System）；Window早期版本（Windows95和Windows NT），Mac OS
    X之前的版本。这种模式有一个问题，如果一个程序进行一个很耗时的计算，一直霸占着CPU不放，那么操作系统也没办法，其他程序只能等着，系统就像死机一样

10. 再次，研究一种更为先进的操作系统模式----多任务系统（Multi-tasking）。操作系统接管了所有硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程的方式运行在比操作系统权限更低的级别。

11. 每个进程都有自己的独立的地址空间，使得进程之间的地址空间相互隔离。CPU由操作系统统一分配，每个进程根据进程优先级的高低都有机会得到CPU，如果运行时间超出了一定时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这被称为抢占式（Preemptive），操作系统可以强制剥夺CPU资源并且分配给他认为目前所需要的进程。如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速地切换，造成了多进程都在同时运行的假象，现代的很多操作系统都采用这种方式：UNIX、Linux、Windows
    NT、Mac OS X等等

    1.  设备驱动

12. 操作系统作为硬件层的上层，她是对硬件的管理和抽象，当成熟的操作系统出现后，硬件被逐渐抽象成了一系列的概念，在UNIX中，硬件设备的访问性是和普通文件的访问形式一样；Windows系统中，图形硬件被抽象成了GDI，声音和多媒体设备被抽象成了DirectX对象，磁盘被抽象成了普通文件系统。驱动程序可以看作是操作系统的一部分，它往往跟操作系统内核一起运行在特权级，但又与操作系统内核之间有一定的独立性，使得驱动程序有比较好的灵活性。驱动程序的开发工作通常由硬件生产厂商完成。

13. 硬盘基本存储单元为扇区（Sector）每个扇区一般为512个字节，一个硬盘往往有很多盘片，每个盘片分为两面，每面按照同心圆划分为若干个磁道，每个磁道划分为若干个扇区。比如一个硬盘有2个盘片，每个盘面分为65536磁道，每个磁道分为1024个扇区，那么硬盘容量为：2\*2\*65536\*1024\*512=137438953472字节（128G），但每个盘面上同心圆的周长不一样，如果按照每个磁道都拥有相同数量的扇区，那么靠近盘面外围的磁道密度比内圈更加稀疏，这样比较浪费空间。但如果不同的磁道扇区数又不同，计算比较麻烦。为了屏蔽这些复杂的硬件细节，现代的硬盘普遍使用一种叫做LBA（Logical
    Block
    Address），即整个硬盘中所有的扇区从0开始编号，一直到最后一个山区，这个扇区编号叫做逻辑扇区号

14. 在Linux系统中，要读取这个文件的前4096个字节，我们使用read的系统调用实现。文件系统收到read的请求后，判断出文件的前4096个字节位于磁盘的1000号逻辑扇区到1007号逻辑扇区，然后文件系统就向硬盘驱动发出一个读取逻辑扇区为1000号开始的8个扇区的请求，磁盘驱动程序收到这个请求以后就向硬盘发出硬件命令，向硬件发送I/O命令有很多种，最常见的一种就是读写I/O端口寄存器实现。在x86，CPU提供了两条专门“in”和“out”来实现对硬件端口的读写

15. 对于IDE接口来说，它有两个通道，分别是IDE0和IDE1，每个通道上可以连接两个设备，分别为Master和Slave，一个PC中最多可以有4个IDE设备，假设我们的文件位于IDE0的Master硬盘上，这也是正常情况下硬盘所在的位置。在PC中，IDE0通道的I/O端口地址是0x1F0\~0x1F7及0x376\~0x377，通过读写这些端口地址就能与IDE硬盘进行通信。我们以实现读取1000号逻辑扇区开始的8个扇区为例：

-   第0x1F3\~0x1F6
    4个字节的端口地址是用来写入LBA地址的，那么1000号逻辑扇区的LBA地址为0x000003E8,所以我们需要往0x1F3、0x1F4写入0x00，网0x1F5xieru
    0x03,往0x1F6写入0xE8

-   0x1F2这个地址用来写入命令所需要读写的扇区数，比如读取8个扇区即写入8

-   0x1F7这个地址用来写入要执行的操作的命令码，对于读取操作来说，命令字为0x20

所以要执行的指令为：

out 0x1F3, 0x00

out 0x1F4, 0x00

out 0x1F5, 0x03

out 0x1F6, 0xE8

out 0x1F2, 0x08

out 0x1F7, 0x20

内存不够怎么办
--------------

1.  操作系统的多任务功能使得CPU能够在多个进程之间很好的共享，从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU。操作系统的I/O抽象模型也很好的实现了I/O设备的共享和抽象

2.  早起计算机，程序是直接运行在物理内存上的，也就是说，程序运行时所访问的地址是物理地址。当然如果一个计算机同时只运行一个程序，那么只要程序要求的内存空间不超过物理内存大小就没有问题

3.  假设计算机有128M内存，程序A需要10M，程序B需要100M，程序C需要20M，如果我们需要同时运行A、B，那么直接的做法是将内存的前100M分配给程序A，10M\~110M分配给B，这样可以实现A、B同时运行。但这存在问题：

-   地址空间不隔离，所有程序都直接访问物理地址，程序所使用的内存空间不是相互隔离的。恶意的程序可以很容易改写其他程序的内存数据

-   内存使用效率低，由于没有有效的内存管理机制，如果我们忽然要运行程序C，这时内存已经不够了，我们想到的一个办法是将其他程序的数据暂时写到磁盘里面，等到需要的时候再读出来。由于程序所需的空间是连续的，这个例子里面，如果换出A是不够的，
    只能将B换出到磁盘，然后将C读入到内存开始运行。这样整个过程会有大量的数据换入换出，导致效率低下

-   程序运行的地址不确定，因为程序每次都需要装入，运行时，我们都需要它从内存中分配一块足够大的空闲区域，这个控线区域的位置是不确定的，但程序编写时，他访问数据和指令跳转时目标地址很多都是固定的，者设计一个重定位问题

1.  解决以上三个问题的思路就是使用我们前文提到过的：增加中间层。使用一种间接地地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射方法，将这个虚拟地址转换成实际物理地址。

    1.  关于隔离

2.  地址空间分为：虚拟地址空间和物理地址空间。虚拟地址空间是不存在的，每个进程都有自己独立的虚拟空间，
    每个进程只能访问自己的地址空间，这就做好了进程的隔离

    1.  分段

3.  分段：是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。映射过程由软件来设置，操作系统设置映射函数，实际的地址转换有硬件来完成

4.  分段的方法基本解决了上面提到的第一个和第三个问题。首先他做到了地址隔离，因为程序A和程序B被映射到了凉快不同的物理空间区域，没有重叠；然后对于每个程序来说，他们被分配到的物理地址的哪一个区域对程序来说都是透明的，他们不需要关心物理地址的变化，所以程序不再需要重定位

5.  分段堆内存区域的映射还是按照程序为单位，如果内存不足，被换入换出到磁盘的都是整个程序，这就是分段方法没有解决的第二个问题；人们很自然的想到了更小力度的内存分割和映射的方法，这就是分页（Paging）

    1.  分页（Paging）

6.  分页的基本方法是把地址空间人为地分成固定大小的页，每页的大小由硬件决定，或者硬件支持多种大小的页，由操作系统选择决定也的大小，比如Intel
    Pentium系列处理器支持4KB或者4MB的页的大小，这两种都是可选的，但同时只能选择一种大小；物理地址空间也是这样的分法

7.  当我们把进程的虚拟地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘里，当需要的时候再把它从磁盘中取出即可。假设我们有两个进程Process1和Process2，他们进程中的部分虚拟页面被映射到了物理页面，比如VP0、VP1和VP7映射到了PP0、PP2、PP3；而有部分页面却在磁盘中，比如VP2和VP3位于磁盘的DP0和DP1，另外有一些页面比如VP4、VP5和VP6可能尚未被用到或者尚未被访问到，他们暂时处于未使用状态。我们把虚拟空间的页叫做虚拟页，把物理内存中的页叫做物理页，把磁盘中的页叫做磁盘页。下图中，Process1的VP2和VP3不在内存中，但当进程需要用到这两个页的时候，硬件捕获到这个消息，这就是所谓的页错误，然后操作系统接管进程，负责将VP2和VP3从磁盘中读出来并且装入内存，然后将内存中的这两个页与VP2和VP3之间建立映射关系。以页为单位来存取和交换这些数据非常方便，硬件本身就支持这种以页为单位的操作方式

8.  保护也是页映射的目的之一，简单地说就是每个页可以设置权限属性，水可以修改，水可以访问，只有操作系统有权限修改这些属性，那么操作系统就可以做到保护自己和保护进程

9.  虚拟存储的实现需要依靠硬件的支持，对于不同的CPU来说是不同的，但是几乎所有的硬件都采用一个MMU（Memory
    Management Unit）

CPU发出的是虚拟地址，经过MMU转换就变成了物理地址

1.  众人拾柴火焰高

    1.  线程基础

2.  线程有时候被称为轻量级进程，是程序执行流最小单元，一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）一个经典的线程与进程之间的关系如下图：

3.  多线程与单线程的进程相比的优势：

-   某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法执行，多线程执行可以有效利用等待的时间

-   某个操作（常常是计算）会消耗大量的时间，如果只有一个线程，
    程序和用户之间的交互会中断，多线程可以让一个线程负责交互，另一个线程负责计算

-   相对于多进程应用，多线程在数据共享方面效率要高很多

1.  线程访问权限：

| 线程私有 | 县城之间共享（进程所有） |
|----------|--------------------------|
| 局部变量 | 全局变量                 |

-   函数的参数

-   TLS数据

-   堆上的数据

-   函数里的静态变量

-   程序代码，任何线程都有权利读取并执行任何代码

-   打开的文件，A线程打开的文件可以有B线程读写

1.  线程调度与优先级

线程总是“并发”执行的，当线程数量小于等于处理器数量是，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但对于线程数量大于处理器数量时，至少有一个处理器会运行多个线程

1.  在单处理器对应多线程的情况下，并发是一种模拟出来的状态，操作系统狐疑让这些多线程程序轮流执行，每次仅仅执行一小段时间（通常是几十到几百毫秒），这样每个线程看起来都在同时执行。这样的一个不断在处理器上切换不同的线程的行为称之为线程调度。县城调度有三种状态：

-   运行：线程正在执行

-   就绪：县城可以理科运行，但CPU已经被占用

-   等待：线程正在等待某一时间发生，无法执行

1.  处于运行中线程拥有一段可以执行的时间，这段时间成为时间片，当时间片用尽的时候，该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件，那么它将进入的等待状态。每当一个线程里开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生之后，该线程将进入就绪状态。如下图：

2.  现在主流的调度方式一般都带有优先级调度和轮转法。所谓轮转法，就是让各个线程轮流执行一小段时间的方法。优先级调度则决定了线程按照什么顺序轮流执行

3.  在Windows中可以使用：BOOL WINAPI SetThreadPriority(HANDLE hThread, int
    nPriority);设置线程的优先级；在Linux下线程相关的操作可以使用pthread库来实现

4.  在Windows和Linux中，线程的优先级不仅可以由用户手动设置，系统还会根据不同线程的表现自动调整优先级，以使得调度更有效率。

5.  在优先级及调度下，存在一种饿死现象，一个线程被饿死是说它的优先级较低，在他执行之前，总是有较高优先级的线程试图执行，因此这个低优先级线程始终无法执行。线程的优先级改变一般有三种方式：

-   用户指定优先级

-   根据进入等待状态的频繁程度提升或者降低优先级

-   长时间得不到执行而被提升优先级

1.  Windows的进程和线程的区别比较标准，Linux下，线程并不是一个通用的概念。Linux将所有的执行实体（无论是线程还是进程）都成为任务，每个任务概念上都类似一个单线程的进程，具有内存空间、执行实体、文件资源等。Linux下不同的人物之间可以选择共享内存空间，实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里面的线程

| 系统调用 | 作用                                 |
|----------|--------------------------------------|
| fork     | 复制当前进程                         |
| exec     | 使用心得可执行映像覆盖当前可执行映象 |
| clone    | 创建子进程并从指定位置开始执行       |

2.  fork产生新任务的速度非常快，因为fork并不复制原任务的内存空间，而是和原任务一起共享一个写时复制的内存空间。所谓写时复制，指的是两个任务可以同时自由地读取内存，但任意一个人物试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他的任务使用。

fork只能够产生本任务的镜像，因此必须使用exec才能够启动别的新任务，exec可以用新的可执行映像替换当前的可执行映像。

fork和exec通常用于产生新任务，如果要产生新县城，则可以使用clone

使用clone可以产生一个新的任务，从指定位置开始执行，并且（可选的）共享当前进程的内存空间和文件等等，如此在实际效果上相当于一个线程

### 线程安全

1.  多线程程序中，可访问的全局变量和对数据随时都可能被其他的线程改变。因此多线程程序在并发时数据的一致性变得非常重要

2.  竞争与原子操作

多线程同时访问一个共享数据的例子：

| 线程1     | 线程2 |
|-----------|-------|
| i=1; ++i; | \--I; |

在许多体系结构上，++i的实现方法：

-   读取i到某个寄存器X

-   X++

-   将X的内容存储回i

由于线程1和线程2兵法执行，因此两个县城的执行序列可能如下：（X[1]和X[2]分别表示线程1和线程2中的X）

| 执行序号 | 执行指令 | 语句执行后变量值 | 线程 |
|----------|----------|------------------|------|
| 1        | i=1      | i=1,X[1]=位置    | 1    |
| 2        | X[1]=i   | i=1,X[1]=1       | 1    |
| 3        | X[2]=i   | i=1,X[2]=2       | 2    |
| 4        | X[1]++   | i=1,X[1]=2       | 1    |
| 5        | X[2]--   | i=1,X[2]=0       | 2    |
| 6        | i=X[1]   | i=2,X[1]=2       | 1    |
| 7        | i=X[2]   | i=0,X[2]=0       | 2    |

从程序逻辑来看，两个线程都执行完毕之后，i的值应该为1，当从之前的执行序列来看i得到的值是0，实际上这两个县城如果同时执行的话，i的结果有可能是0或者1或者2

1.  我们把单指令的操作成为原子的，无论如何，单条指令的执行时不会被打断的

2.  Windows里的一些原子操作，这些API成为Interlocked API

| Windows API          | 作用               |
|----------------------|--------------------|
| InterlockedExchange  | 原子地交换两个值   |
| InterlockedDecrement | 原子地减少一个值   |
| InterlockedIncrement | 原子地增加一个值   |
| InterlockedXor       | 原子地进行异或操作 |

3.  同步与锁

为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们需要将各个线程对同一个数据的访问同步，所谓同步，即是指在一个线程访问数据未结束时，其它线程不得对同一个数据进行访问

同步的最常见的方法是使用锁，锁是一种非强制机制，每个线程在访问数据或者资源之前首先试图获取锁，并在访问结束后释放锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用

二元信号量：最简单的一种锁，它只有两种状态：占用或者非占用。他适合只能被唯一一个线程独占访问的资源，当二元信号量处于非占用的状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，其他的所有视图获取该二元信号量的线程将会等待，直到该锁被释放

多元信号量：允许多个线程并发访问的资源，一个初始值为N的信号量允许N个线程并发访问，县城访问资源的时候首先获取信号量，进行如下操作：

-   将信号量的值减1

-   如果信号量的值小于0，则进入等待状态，否则继续执行

-   访问完资源之后，线程释放信号量，进行如下操作：

-   将信号量的值加1

-   如果信号量的值小于1，唤醒一个等待中的线程

互斥量：它跟二元信号量很相似，资源仅同时允许一个线程访问，但和信号量不同的是信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的饿一个线程获取之后由另一个线程释放，而互斥量则要求哪个线程获取了互斥量，哪个线程就负责释放这个锁，其他线程释放这个互斥量是无效的

临界区：是比互斥量更为严格的同步手段，在属于中，把临界区的锁的获取成为进入临界区，把锁的释放成为离开临界区，临界区和互斥量与信号量的区别在于，互斥量和信号量在系统中的任何进程都是可见的，一个进程创建了一个互斥量或者信号量，另一个晋城市图去获取这个锁是合法的。临界区的作用范围仅限于本进程，其他进程无法获取该锁，临界区具有和互斥量相同的性质

读写锁：它致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型的，只要有任何一个线程试图对这个数据进行修改，就必须使用同步手段来避免出错。对于同一个锁，读写锁有两种方式：共享的或者独占的。当锁处于自由的状态时自由状态时，将试图以任何方式获取所都能成功，并将锁至于对应的状态；如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程；如果其它线程试图以独占的方式获取已经处于共享状态的锁，那么它将必须等待所备所有的线程释放。处于独占状态的锁，不论他们试图以哪种方式获取，如下表：

| 读写锁状态 | 以共享方式获取 | 以独占方式获取 |
|------------|----------------|----------------|
| 自由       | 成功           | 成功           |
| 共享       | 成功           | 等待           |
| 独占       | 等待           | 等待           |

条件标量：一种同步手段，作用类似于一个栅栏。对于条件变量，可以有两种操作。首先线程可以等待条件变量，一个条件变量可以被多个线程等待，其次，线程可以唤醒条件变量，此时某个或者所有等待次条件变量的线程都会被唤醒并继续支持。使用条件变量可以让多个线程一起等待某个事件发生，当事件发生时，所有县城可以一起恢复执行

1.  可重入与线程安全

一个函数被重入，表示这个函数没有执行完成，由于外部因素或者内部调用，有一次进入该函数执行。一个函数要被重入，只有两种情况：

-   多个线程同时执行这个函数

-   函数自身调用自身

1.  一个函数是可重入的，比如有如下特点：

-   不适用任何（局部）静态或者全局非const变量

-   不反悔任何（局部）静态或者全局的非const变量的指针

-   仅依赖于调用方提供的参数

-   不依赖任何单个资源的锁

-   不调用任何不可重入的函数

1.  过度优化

因为即使合理使用了锁，也不一定能保证线程安全，只是源于落后的编译器即使已经无法满足日益增长的并发需求。例子：

x=0;

Thread1 Thread2

lock(); lock();

x++; x++;

unlock(); unlock();

由于lock和unlock的保护，x++的行为不会被并发破坏，那么x的值似乎必然是2了。然而，如果编译器为了提高x的访问速度，把x
放到了某个寄存器里面，那么我们知道不同线程的寄存器是各自独立的，因此Thread1先获得锁，则程序会出现以下情况：

[Thread1]读取x的值到某个寄存器R[1](R[1]=0)

[Thread1] R[1]++(由于之后可能还要访问x，因此Thread1暂时不将R[1]写回x)

[Thread2]读取x的值到某个寄存器R[2](R[2]=0)

[Thread2] R[2]++(R[2]=1)

[Thread2] 将R[2]写回至x(x=1)

[Thread1]（很久以后）将R[1]写回至x(x=1)

可见在这样的概况下即使正确地加锁，也不能保证多线程安全，下面是另一个例子：

x=y=0

Thread1 Thread2

x=1; y=1;

r1=y; r2=x;

很明显r1和r2至少有一个是1，逻辑上不可能同时为0.然而，事实上同时为0是可能发生的。早在几十年前，CPU就发展除了动态调度，在执行程序的时候为了提高效率有可能交换指令顺序。编译器在进行有话的时候，也可能为了效率而交换毫不相干的两条相邻的指令（如x=1和r1=y）的执行顺序，也就是上述代码执行的时候可能是这样的：

x=y=0

Thread1 Thread2

r1=y; y=1;

x=1; r2=x;

那么r1=r2=0是完全可能的，我们可以使用volatile关键字阻止过度优化，volatile基本可以做两件事情：

-   组织编译器为了提高速度将一个变量缓存到寄存器内而不写回

-   组织编译器调整操作volatile变量的指令顺序

volatile可以解决第一个问题，大海寺不能解决第二个问题。因为即使volatile能够阻止编译器调整顺序，也无法阻止CPU动态调度换序

1.  并不存在可一直的阻止换序的方法，通常情况下是调用CPU提供一条指令，这条指令尝尝被称为barrier。一条barrier指令会阻止CPU将该指令之前的指令交换到barrier之后

    1.  多线程内部情况

2.  线程的并发执行时由多处理器或者操作系统调度来实现的。包括Windows和Linux都在内核里面提供线程支持。用户实际使用的线程并不是内核线程，而是存在用户态的用户线程。用户态线程并不一定在操作系统内核里面对应同等数量的内核线程。

一般直接使用API或者系统调用创建的线程均为一对一县城，例如Linux里面使用clone（带有CLONE_VM参数）产生一个线程就是一个一对一线程。Windows里面，使用API
Create Thread即可创建一个一对一线程。一对一县城缺点有两个：

-   由于许多操作系统限制了内核线程的数量，由此一对一县城会让用户的线程数量收到限制

-   许多操作系统内核线程调度时，上下文切换开销较大，导致用户线程的执行效率下降

多对一模型的问题是其中一个用户线程阻塞，那么所有的线程都将无法执行，因为此时内核里面的线程也随之阻塞了。多对一模型的好处是搞笑的上下文切换和几乎无限制的线程数量

多对多模型中，一个用户线程阻塞并不会使得所有的用户线程阻塞

1.  静态链接

    1.  被隐藏了的过程

2.  一个HelloWorld.c：

\#include\<stdio.h\>

int main()

{

printf(“Hello World\\n”);

return 0;

}

使用gcc HelloWorld.c生成a.out

上述过程可以分为4个步骤：预处理、编译、汇编、链接

### 预编译过程

1.  首先是源代码文件HelloWorld.c和相关的头文件，如stdio.h等被预编译器cpp预编译成一个.i文件.对于C++程序来说，他的源代码文件的扩展名可能是.cpp或者.cxx，头文件的扩展名可能是.hpp，预编译后的文件名可能是.ii。第一步预编译的过程相当于以下命令：

gcc –E HelloWorld.c –o hello.i或者cpp HelloWorld.c \> hello.i

1.  预编译的过程主要处理那些源代码文件中的以“\#”开始的预编译指令。比如“\#include”或者“define”等等，主要处理如下：

-   将所有的“\#define”删除，并且展开所有的宏定义

-   处理所有条件预编译指令，比如“\#if/\#ifdef/\#elif/\#else/\#endif”

-   处理“\#include”与编译指令，将被包含的文件插入到该与编译指令的位置，注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件

-   删除所有的注释“//”和“/\*\*/”

-   添加行号和文件名标识，比如\#2”HelloWorld.c”2，以便预编译是编译器产生调试用的行号信息及用于编译时产生编译错误或者警告时能够显示行号

-   保留所有的\#pragma编译器指令，因为编译器需要使用他们

1.  经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中

    1.  编译

2.  编译过程就是巴渝处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。编译过程相当于如下命令：

gcc –S hello.i –o hello.s

1.  现在版本的gcc把预编译和变异两个步骤合并成一个步骤，使用一个叫做ccl的程序来完成这两个步骤：ccl
    HelloWorld.c或者使用：gcc –S HelloWorld.c –o hello.s

对应的C++有cclplus，Java是jcl

实际上gcc这个命令只是这些后台程序的包装，，它会根据不同的参数要求去掉用预编译编译程序ccl、汇编器as、链接器ld

### 汇编（看《零基础入门学习汇编语言源码》）

1.  汇编器是将汇编代码转变成机器可以执行的指令，每个汇编语句几乎都对应一条机器指令。汇编过程相对于编译器来讲比较简单。没有复杂的语法、没有语义、没有指令优化，只是根据汇编指令和机器指令对照表一一翻译。汇编命令：as
    hello.s –o hello.o或者使用：gcc –c HelloWorld.c –o hello.o

    1.  链接

后面会详细介绍

编译器做了什么
--------------

1.  从最直观的角度来讲，编译器就是将高级语言翻译成机器语言的一个工具，高级语言的可以之行也使得它在多种计算机平台下能够游刃有余

2.  编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化

3.  比如我们有一行C语言的源代码：

array[index] = (index + 4) \* (2 + 6)

CompilerExpression.c

### 词法分析

1.  源代码被输入到扫描器（Scanner），扫描器的任务很简单，他只是简单地进行词法分析，运用一种类似于有限状态机的算法可以很轻松地将原代码的字符序列分割成一系列的记号（Tokens）。比如上面的程序，总共包含了28个非空字符，经过扫描仪后，产生16个记号：

| 记号  | 类型     |
|-------|----------|
| array |          |
| [     | 左方括号 |
| index | 标识符   |
| ]     | 右方括号 |
| =     | 赋值     |
| (     | 左圆括号 |
| index | 标识符   |
| \+    | 加号     |
| 4     | 数字     |
| )     | 右圆括号 |
| \*    | 乘号     |
| (     | 左圆括号 |
| 2     | 数字     |
| \+    | 加号     |
| 6     | 数字     |
| )     | 右圆括号 |

词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量（包含数字、字符串等等）和特殊符号（如加号、等号）。在标识记号的同时，大扫描企业完成了其他工作，比如将标识符存放到符号表，将数字、字符串常量存放到文字表等。有一个叫做lex的程序可以实现词法扫描

### 语法分析

1.  词法分析器（Grammar
    Parser）将对有扫描器产生的记号进行语法分析，从而产生语法树（Syntax
    Tree）。整个分析过程采用了上下文无关语法（Context-free
    Grammar）的分析手段，如上下文无关语法及下推自动机。

由语法分析器生成的语法树就是以表达式（Expression）为结点的树。上面的例子中的语句就是一个由赋值表达式、假发表达式、惩罚表达式、数组表达式、括号表达式组成的复杂语句，经过语法分析器以后形成语法树：

1.  符号和数字是最小的表达式，他们不是有其他的表达式来组成的，所以它们通常作为整个语法树的叶节点。在语法分析的同时，很多运算符的优先级和含义也被确定下来了。

2.  如果出现了表达是不合法，比如各种括号不匹配、表达式中缺少操作符等等，编译器就汇报稿语法分析阶段的错误。语法分析也有一个现成的工具，叫做yacc

    1.  语义分析

3.  语法分析仅仅是完成了对表达式的语法层面的分析。便以其所能分析的是静态语义（Static
    Semantic），所谓静态语义是指在编译器可以确定的语义，与之对应的动态语义就是只有在运行期才能确定的语义。静态语义通常包括生命和类型的匹配，类型转换。

经过语义分析阶段以后，整个语法树的表达式都被标识了类型，如果有些类型需要做饮食转换，语义分析程序会在语法树中插入相应的转换节点，下面是经过语义分析阶段以后：

### 中间语言生成

1.  现代的编译器有很多层次的优化，往往在源代码级别会有一个优化过程。源代码及优化器在不同的编译器有不同的定义或者不同的差异。源代码及优化器会在源代码级别进行优化。比如（2+6）这个表达时就会被优化掉，因为它的值可以在编译器就可以被确定

2.  直接在语法书上做优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码，它是语法树的顺序表示。中间代码已经非常接近目标代码了，但他一般跟目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器的名字等等，中间代码有很多类型，在不同的编译器中有着不同的形式，比较常见的是：三地址吗和P-代码。

3.  最基本的三地址吗是：x = y op
    z.我们上面的例子中的语法树可以被翻译成三地址码后是这样的：

>   t1 = 2 + 6

>   t2 = index +4

>   t3 = t2 \* t1

>   array[idnex] = t3

>   为了使所有的操作都符合三地址码形式，这里利用了几个临时变量：t1,t2,t3.在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1=8.然后将后面的代码中的t1替换成数字8.这样还可以省去一个临时变量t3，因为t2可以重复利用。经过优化后代码如下：

>   t2 = index +4

>   t2 = t2 \* 8

>   array[index] = t2

>   中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。

### 目标代码的生成和优化

1.  编译器后端主要包括代码生成器和目标代码优化器。代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器。因为不同的机器有着不同的字长、寄存器、整数数据类型、浮点数据类型

2.  经过这些扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化，编译器经过了这么多步骤之后，源代码被编译成目标代码。但是这个目标代码有个问题：idnex
    和array
    的地址还没确定。如果我们要把目标代码使用汇编编译成真正的能够在机器上执行的指令，那么index
    和array的地址应该从哪得到呢？如果index和array定义在跟上面的源代码同一个编译单元里面，那么编译器可以为index和array
    分配空间，确定他们的地址：那么如果是定义在其他程序模块呢。

3.  定义其他模块的全局变量和函数在最终运行时的绝对定制都要在最终连接的时候才能确定

    1.  链接器年龄比编译器长

4.  以前的程序是打孔，每个孔表示以为，穿孔表示0，未穿孔表示1.现在问题来了，程序并不是一写好就永远不变化的。比如我们在第一条指令之后、第五条指令之前插入了一条或者多条指令，那么第五条指令集后面的指令的位置将会相应地往后移动，原先第一条指令的低四位的数字将需要调整。在这个过程中，程序员需要人工重新计算每个子程序或者跳转的目标地址。当程序修改的时候，这些位置都需要重新计算，繁琐耗时，容易出错，这种重新计算各个目标的地址过程被叫做重定位

5.  符号这个概念随着汇编语言而普及，它用来表示一个地址，这个地址可能是一段子程序（后来发展成函数）的起始地址，也可能是一个变量的起始地址

6.  模块之间如何组合的问题可以归纳为模块之间如何通信的问题，最常见的属于静态语言的C/C++模块之间通信有两种方式：一种是模块间的函数调用，另一种是模块间的变量的访问。

7.  函数访问必须知道目标函数的地址，变量范文也需要知道目标变量的地址。左移这两种都归结为一种方式：模块之间符号的引用

    1.  静态链接

8.  人们把每个源代码模块独立地编译，然后按照需要将他们组装起来，这组装模块的过程就是连接。连接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确的衔接

9.  链接器的工作无非就是把一些指令对其他符号地址的引用加以修正。链接过程主要包括了地址和空间分配、符号决议和重定位这些步骤

10. 符号决议有时候也叫做符号绑定、名称绑定、名称决议、指令绑定

11. 在程序模块main.c中使用另外一个模块func.c中的函数foo()。我们在main.c模块中每一处调用的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译main.c的时候他并不知道foo函数的地址，所以它暂时把这些调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。

12. 如果没有链接器，则需要我们手工修正foo里面的地址。当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦

13. 使用连接器，你可以直接饮用其他模块的函数和全局变量而无需知道他们的地址，因为连接器在连接的时候，会根据你所引用的符号foo，自动取相应的func.c模块查找foo的地址，然后将main.c模块中所有以后能用到foo的指令重新修正，让他们的目标地址为真正的foo函数的地址，这就是静态联机的最基本的过程和作用

14. 假设我们有个全局变量叫做var，他在目标文件A里面，我们在目标文件B里面要访问这个全局变量，比如我们在目标B里面有这么一条指令：movl
    \$0x2a, var

由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在无法确定地址的情况下，将这条mov指令的目标地址置为0，等待链接器在连接的时候修正。我们假设A和B连接后，变量var的地址确定下来为0x1000，那么链接器将会把这个指令的目标地址部分修改成0x10000，这个修正的过程被叫做重定位，每个修正的地方叫一个重定位入口。

目标文件里有什么
================

1.  目标文件里面到底存放的是什么？

2.  源代码在经过编译后是怎么存储的？

3.  目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过连接的过程，其中可能有些符号或者有些地址还没有被调整。其实他本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。

    1.  目标文件的格式

4.  现在PC平台流行的可执行文件格式主要是Windows下的PE和Linux的ELF，他们都是COFF格式的变种。目标文件就是源代码编译后但未进行连接的那些中间文件（Windows的.obj和Linux的.o）在Windows下，我们统称目标文件和可执行文件为PE-COFF文件格式，在Linux下，我们将它们统称为ELF文件

5.  可执行文件按照可执行文件格式存储，动态链接库及静态链接库都按照可执行文件格式存储。在windows下按照PE-COFF格式存储，Linux下按照ELF格式存储。静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，你可以简单的把它理解为包含很多目标文件的文件包。

| ELF文件类型  | 说明                                                                                                                                                                                                                               |                                 |
|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------|
| 可重定位文件 | 这类稳健包含了代码和数据，可以被用来连接成可执行文件或者共享目标文件，静态链接库也可归为此类                                                                                                                                       | 比如.o或者.obj                  |
| 可执行文件   | 这类文件包含了可以直接执行的程序，他的代表就是ELF可执行文件，一般没有扩展名                                                                                                                                                        | 比如/bin/bash文件 Windows的.exe |
| .so          | 这种文件包含了代码和数据，可以在以下两种情况下使用，一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，生成新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程影响的一部分来运行 | Linux下的.so Windows的DLL       |
| 核心转储文件 | 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件                                                                                                                                         | Linux下的core dump              |

Linux下可以使用file命令来查看相应的文件格式

![](media/1bfa41bb25740f8bf00cd15152f78b3e.png)

目标文件是什么样的
------------------

1.  目标文件中的内容至少有编译后的机器指令代码、数据。目标文件中还包括了连接时所必须的信息，比如符号表、调试信息、字符串等。

2.  程序源代码表以后的机器指令经常被放在代码段里。代码段常见的名字有“.code”或者“.text”。全局变量和局部静态变量数据经常放在数据段，一般为“.data”

3.  ELF
    文件的开头是一个“文件头”，他描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等等信息。文件头还包括一个段表，段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段再文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息。文件头后面就是各个段的内容，比如代码段保存的就是程序的指令，数据段保存的就是程序的静态变量等等

4.  一般C语言的编译后执行的语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一个叫“.bss”段；

5.  未初始化的全局变量和局部静态变量都默认为0，本来他们可以放在.data段的，但是因为他们是0，所以为他们在.data段分配空间并且存放0没有必要。程序运行的时候他们的确是要占内存空间的。并且可执行文件必须记录所有未初始化的全局变量和局部静态变量的大小总和，记为.bss段；所以.bss段只是为未初始化的全局变量和局部静态变量预留位置，他并没有内容，所以它在文件中也不占据空间

6.  为什么那么麻烦将程序的指令和数据的存放分开？

-   一方面是当程序被装载后，数据和指令分别被映射到两个虚存区域，由于数据区域对于进程来说是可读写的，而指令区域对于进程时制度的，所以这两个虚存区域的权限是不同的，这样可以防止程序的指令被有意无意的改写

-   另外一方面是对于现代的CPU来说，他们有着极为强大的缓存体系。由于缓存在现代的计算机中地位非常重要，所以程序必须尽量提高缓存的命中率。指令区和数据区的有利于提高程序的局部性。现在CPU的缓存一般都被设计为数据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处

-   系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只需要保存一份该程序的指令部分。每个副本进程的数据区域是不一样的，他们是进程私有的

    1.  挖掘SimpleSection.o

1.  代码：

/\*

SimpleSection.c

Linux: gcc –c SimpleSection.c

Windows: cl SimpleSection.c /c /Za

\*/

int printf(cosnt char \*format, …);

int global init_val = 84;

int global_uninit_var;

void funl(int i)

{

printf(“%d\\n”, i);

}

int main()

{

static int static_var = 85;

static int static_var2;

int a = 1;

int b;

funcl(static_var + static_var2 + a + b);

return 0;

}

目标文件：

![](media/99076ad05e843a3e8cff769e9333601c.png)

参数“-h”就是把ELF文件的各个段的基本信息打印出来,但是省略了一些辅助段；“objdump
-x”可以把更多的信息打印出来。

以上“CONTENTS”、“ALLOC”表示段的各种属性；“CONTENTS”表示该段在文件中存在；我们可以看到BSSdaunt没有“CONTENTS”，表示他实际上在ELF文件中不存在内容。“.note.GNU-stack”段虽然有“CONTENTS”，但是他的长度为0

1.  ELF文件中，“.text”、“.data”、“.rodata”、“.comment”段长度、在文件中的偏移位置：

size命令，可以查看ELF文件的代码段、数据段、BSS段的长度，

![](media/4e37bddfd32172861e7fd24c37660276.png)

### 代码段

1.  objdump
    –s可以将所有的段的内容以16进制的方式打印出来，“-d”参数可以讲所有包含指令的段反汇编。

![](media/50b526fef9b21bca78176348aaa7ac6f.png)

“Contens of section
.text”就是.text的数据以16进制方式打印出来的内容，总共0x5b字节。最左边一列是偏移量，中间4列是16进制内容，最右面一列是.text的ASCII码形式。对照下面的反汇编结果，可以看到，.text段里面所包含的正是SimpleSection.c里两个函数funcl和main函数的指令。.text的第一个自己“0x55”就是“funcl()”的第一条是”push
%ebp”指令，而最后一个字节0xc3正是main()函数的最后一条指令”ret”

### 数据段和只读数据段

1.  .data段保存的是哪些已经初始化了的全局静态变量和局部静态变量。SimpleSection.c里面我们在调用“printf”的时候，用到了一个字符串常量“%d\\n”，它是一种只读数据，所以把它放在”.rodata”段。这个段一般是程序里面的制度变量（如const修饰的变量）和字符串常量。单独设立“.rodata”段有很多好处，不光在语义上支持了C++的const关键字，而且操作系统在加载的时可以讲“.rodata”段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性

2.  有时候编译器会把字符串常量放到“.data”段，而不会单独放在“.rodata”段

![](media/1b853b3b2d5a95cdab10c651b20b292d.png)

global_init_varabal是4字节长度的int类型，为什么存放的次序是0x54,0x00,0x00,0x00而不是0x00,0x00,0x00,
0x54这是大端、小端的问题

### BSS段

1.  有些编译器会将全局的未初始化变量存放在目标文件.bss段，有些则不存放，只是预留一个未定义全局变量符号，等到最终连接成可执行文件的时候再在.bss段分配空间

2.  例子：static int x1 = 0;static int x2 =
    1;x1和x2被放在什么段中？x1会被放在.bss，x2会被放在.data。为什么这样呢，应为x1=0，可以认为是未初始化的，因为未初始化的等候室0，所以被优化掉了可以放在.bss，这样可以节省磁盘空间

3.  其他段

| 常用段名    | 说明                                                                                     |
|-------------|------------------------------------------------------------------------------------------|
| .rodatal    | Read only Data，这种段里存放的是只读数据，比如，字符串常量，全局const变量，跟.rodata一样 |
| .comment    | 存放的是编译器版本信息，比如字符串：“GCC(GNU)4.2.0”                                      |
| .debug      | 调试信息                                                                                 |
| .hash       | 符号哈希表                                                                               |
| .dynamic    | 动态链接信息                                                                             |
| .line       | 调试时的行号表，即源代码行号与编译后指令的对应表                                         |
| .note       | 额外的编译器信息，比如程序的公司名，发布版本号等等                                       |
| .strtab     | StringTable字符串表，用于存储ELF文件中用到的各种字符串                                   |
| .symtab     | Symbol Talble 符号表                                                                     |
| .shstrtab   | Section String Table 段名表                                                              |
| .plt .got   | 动态链接的跳转表和全局入口表                                                             |
| .init .fini | 程序初始化和终结代码段                                                                   |

这些段的名字都是由”.”作为前缀，表示这些表的名字都是系统保留的。但是应用程序自定义的段名表不能使用“.”作为前缀，否则容易跟系统保留段名冲突。一个ELF文件也可以拥有几个相同的段名的段，比如一个ELF文件中可能有两个或者两个以上叫做“.text”的段

1.  如果我要将一个二进制文件，比如图片、MP3音乐、词典一类的东西作为目标文件中的一个段，该怎么做？

可以使用objcopy工具，比如我们有一个图片“image.jpg”大小为0x82100字节：

![](media/e136638b9747da592028ca4a85deb469.png)

符号“_binary_iamge_jpg_start”、“_binary_image_jpg_end”、“_birnary_image_jpg_size”分别表示该图片文件在内存中的起始地址、结束地址和大小，我们可以在程序里面直接声明并使用他们

1.  自定义段

gcc提供了扩展机制，使得程序员可以指定变量所处的段：

\__attribute__((section(“FOO”))) int global=42;

\__attribute__((section(“BAR”))) void foo(){}

我们在全局变量或者函数之前加上“__attribute__((section(“name”)))”属性就可以把相应的变量或者函数放到以”name”作为段名的段中

ELF文件结构描述
---------------

| ELF Header                    |
|-------------------------------|
| .text                         |
| .data                         |
| .bss                          |
| …other sections               |
| Section header table          |
| String Tables Symbol Tables … |

Table ELF 结构

1.  ELF目标文件式的最前部是ELF文件头，它包含了描述整个文件的基本属性。比如ELF文件版本、目标机器型号、程序入口地址等等。紧接着是ELF文件各个段。ELF文件中，与段有关的重要结构就是段表（Section
    Header
    Table），该表描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、再文件中的偏移、读写权限及段的其他属性。

2.  文件头

readelf命令查看ELF文件

![](media/f23bbddf89d6f316241cab821737ffe1.png)

ELF的文件头中定义了ELF魔数、文件及其字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序投入口和长度、段表的位置和长度以及段的数量

1.  ELF文件头结构及相关常数被定义在“/usr/include/elf.h”因为ELF文件在各种平台下都通用，ELF文件有32位版本和64位版本。他的文件头结构也有两种版本：“Elf32_Ehdr”和“Elf64_Ehdr”。32位版本和64位版本的ELF文件的文件头内容是一样的，只不过有些成员的大小不一样。elf.h使用typedef定义了一套自己的变量体系：

| 自定义类型             | 描述                                  | 原始类型         | 长度（字节） |
|------------------------|---------------------------------------|------------------|--------------|
| Elf32_Addr             | 32位版本程序地址                      | uint32_t         | 4            |
| Elf32_Half             | 32位版本的无符号短整型                | uint16_t         | 2            |
| Elf32_Off              | 32位版本的偏移地址                    | uint32_t         | 4            |
| Elf32_Sword Elf32_Word | 32位版本有符号整形 32位版本无符号整形 | uint32_t int32_t | 4 4          |
| Elf64_Addr             | 64位版本程序地址                      | uint64_t         | 8            |
| Elf64_Half             | 64位版本的无符号短整型                | uint16_t         | 2            |
| Elf64_Off              | 64位版本的偏移地址                    | uint64_t         | 8            |
| Elf64_Sword            | 64位版本有符号整型                    | uint32_t         | 4            |
| Elf64_Word             | 64位版本无符号整型                    | int32_t          | 4            |

以32位版本的文件头结构“Elf32_Ehdr”作为例子描述，定义如下：

typedef struct

{

unsigned char e_ident[16];

Elf32_Half e_type;

Elf32_Half e_machine;

Elf32_Word e_version;

Elf32_Addr e_entry;

Elf32_Off e_phoff;

Elf32_Off e_shoff;

Elf32_Word e_flags;

Elf32_Half e_ehsize;

Elf32_Half e_phentsize;

Elf32_Half e_phnum;

Elf32_Half e_shentsize;

Elf32_Half e_shnum;

Elf32_Half e_shstrndx;

}Elf32_Ehdr;

除了“Elf32_Ehdr”中的e_ident这个成员对应了输出的“Class、Data、Version、OS/ABI和ABI
Version”这五个参数，剩下的参数与“Elf32_Ehdr”中的成员都一一对应。

1.  ELF文件头中各个成员的含义与readelf 输出结果的对照表

| 成员      | readelf输出结果与含义                                                                                                                                         |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| e_ident   | Magic: 7f 45 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data 2’s complement, little endian Version: 1(current) OS/ABI: UNIX-System V ABI Version: 0  |
| e_type    | Type REL(Relocatable file) ELF文件类型                                                                                                                        |
| e_machine | Machine Intel 80386 ELF 文件的CPU平台属性。相关常量以EM_开头                                                                                                  |
| e_version | Version: 0x1 ELF版本号。一般为常数1                                                                                                                           |
| e_entry   | Entry point address: 0x0 入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。可重定位文件一般没有入口地址，则这个值为0 |
| e_phoff   | Start of program headers: 0(bytes into file) 这个暂时不关心，请参考后面“ELF链接视图和执行视图”                                                                |
| e_shoff   | Start of section headers: 289(types into file) 段表在文件中的偏移，上面的例子里这个值是280，也就是段表从文件中的第281个字节开始                               |

Table ELF文件头结构成员含义

1.  如下图：

Table ELF魔数

最开始的4个字节时所有ELF文件都必须相同的标识码：0x7f 0x45 0x4c
0x46，第一个字节对应的ASCII字符里面的ELF控制符，后面3个字节刚好是ELF这3个字符的ASCII码。这4个字节又被称为ELF文件的魔数

几乎所有的可执行文件格式的最开始的几个字节都是魔数。比如a.out格式最开的两个字节为：0x01
0x07;PE/COFF文件最开始两个字节为：0x4d
0x5a，即ASCII字符MZ。这种魔术用来确认文件的类型，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载

接下来的一个字节是用来表示ELF的文件类的。0x01表示式32位的，0x02表示式64位的；第6个字是字节序，规定该ELF文件时大端的或者是小端的。第7个字节规定ELF文件的主版本号，一般是1，因为ELF标准在1.2版以后就再也没有更新了，后面9个字节ELF标准没有定义，一般填写0

1.  e_type成员表示ELF文件类型。系统通过这个常量来判断ELF的真正类型，而不是通过文件的扩展名字。相关常量以“ET_”开头：

| 常量    | 值 | 含义                        |
|---------|----|-----------------------------|
| ET_REL  | 1  | 可重定位文件，一般为.o文件  |
| ET_EXEC | 2  | 可执行文件                  |
| ET_DYN  | 3  | 共享目标文件，一般为.so文件 |

2.  机器类型：ELF文件格式被设计成可以在多个平台下使用。这并不表示同一个ELF文件可以在不同的平台下使用，而是表示不同平台下的ELF文件都遵循同一套属性。e_machine成员就表示该ELF文件的平台属性。比如表示ELF文件只能在Intel
    x86及旗下适用，相关的常量以“ET_”开头：

| 常量          | 值  | 含义                          |
|---------------|-----|-------------------------------|
| EM_M32        | 1   | AT&T WE 32100                 |
| EM_SPARC      | 2   | SPARC                         |
| EM_386        | 3   | Intel x86                     |
| EM_68K EM_88K | 4 5 | Motorola 68000 Motorola 88000 |
| EM_860        | 6   | Intel 80860                   |

3.  段表：段表（Section Header
    Table）就是保存这些段的基本属性的结构。他描述了ELF的各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限以及段的其他属性。ELF文件的段结构就是由段表决定的。编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性。段表在ELF文件中的位置由ELF文件头的“e_shoff”成员决定的。比如SimpleSection.o中，段表位于偏移0x118

4.  使用readelf工具来查看ELF文件的段，它显示出的结果才是真正的段表结构：

![](media/a6ee5e8abe2ff917b5a8457f547a1cab.png)

段表的结构比较简短，他是一个以“Elf32_Shdr”结构体为元素的数组。数组元素的个数等于段的个数，每个“Elf32_Shdr”结构体对应一个段。“Elf32_Shdr”又被称为段描述符。ELF段表的这个数组的第一个元素是无效的段描述符，他的类型是“NULL”。=，除此之外每个段描述符都对应一个段。也就是SimpleSection.o共有10个有效的段

1.  Elf32_Shdr被定义在“/usr/include/elf.h”：

typedef struct

{

Elf32_Word sh_name;

Elf32_Word sh_type;

Elf32_Word sh_flags;

Elf32_Word sh_addr;

Elf32_Word sh_offset;

Elf32_Word sh_size;

Elf32_Word sh_link;

Elf32_Word sh_info;

Elf32_Word sh_addralign;

Elf32_Word sh_entsize;

}Elf32_Shdr;

含义如下所示：

| sh_name          | Section name 段名 段名是个字符串，它位于一个叫做“.shstrtab”的字符串表，sh_name是短命字符串在“.shstrtab”中的偏移                                                                                                                                                                                                                                                                                                                                                                                                                  |
|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| sh_type          | Section type 段的类型                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| sh_flags         | Section Address段的标志位                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| sh_addr          | Section Address段虚拟地址 如果该段可以被加载，即sh_addr为该段被加载后在进程地址空间中的虚拟地址，否则sh_addr为0                                                                                                                                                                                                                                                                                                                                                                                                                  |
| sh_offset        | Section Offset段偏移 如果该段存在于文件中，则表示改短再文件中的偏移；否则无意义，比如sh_offset对于BSS段来说就没有意义                                                                                                                                                                                                                                                                                                                                                                                                            |
| sh_size          | Section Size段的长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| sh_link和sh_info | Section Link and Section Information段链接信息                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| sh_addralign     | Section Address Alignment段地址对齐 有些段对段地址对齐有要求，比如我们假设有个段刚开始的位置办函了一个double变量，因为Intel x86系统要求浮点数的存储地址必须是本身的整数倍，也就是说保存double变量的地址必须是8字节的整数倍。这样对于一个端来说，他的sh_addr必须是8的整数倍 由于地址对齐的数量都是2的指数倍，sh_addralign表示式地址对齐数量中的指数，即sh_addrlign=3表示对齐为2的3次方。以此类推，所以一个段的地址sh_addr必须满足下面的条件，即sh_addr % (2 \*\* sh_addralign)=0 如果sh_addralign为0或者1，则表示该段没有对齐要求 |
| sh_entsize       | Section Entry Size项的长度 有些段包含了一些固定大小的项，比如符号表，它包含的每个符号所占用的大小都是一样的，对于这种段，sh_entsize表示每个项的大小。如果为0，则表示该段不包含固定大小的项                                                                                                                                                                                                                                                                                                                                       |

事实上段的名字对于编译器、链接器来说是有意义的，但是对于操作系统来说并没有实质性的意义。对于操作系统来说，一个段该如何处理取决于它的属性和权限，即由短的类型和段的标志位这两个成员决定

1.  中间Section
    Table和.rel.text都因为对齐的原因，与前面的段之间分别有一个字节和两个字节的间隔

2.  段的类型（sh_type）：段的名字只是在连接盒编译过程中有意义。但她不能真正的表示段的类型。我们也可以将一个数据段明明为“.text”。对于编译器和链接器来说，主要决定段的属性的是段的类型和段的标志位（sh_flags）。段的类型相关常量以SHT_开头：

| 常量         | 值 | 含义                               |
|--------------|----|------------------------------------|
| SHT_NULL     | 0  | 无效段                             |
| SHT_PROGBITS | 1  | 程序段，代码段和数据段都是这种类型 |
| SHT_SYMTAB   | 2  | 表示该段的内容为符号表             |
| SHT_STRTAB   | 3  | 表示该段的内容为字符串表           |
| SHT_RELA     | 4  | 重定位表。该段包含了重定位信息     |
| SHT_HASH     | 5  | 符号表的哈希表                     |
| SHT_DYNAMIC  | 6  | 动态链接信息                       |
| SHT_NOTE     | 7  | 稀释性信息                         |
| SHT_NOBITS   | 8  | 表示该段在文件中没内容，比如.bss   |
| SHT_REL      | 9  | 该段包含（重定位信息）             |
| SHT_SHLIB    | 10 | 保留                               |
| SHT_DNYSYM   | 11 | 动态链接的符号表                   |

3.  段的标志位：表示该段在进程中虚拟地址空间中的属性，比如是否可行，是否可执行，相关常量以SHF_开头：

| 常量         | 值 | 含义                                                                                                                                                      |
|--------------|----|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| SHF_WRITE    | 1  | 表示该段在进程空间中可写                                                                                                                                  |
| SHF_ALLOC    | 2  | 表示该段在进程空间中药分配空间。有些包含指示或者控制信息的段不需要再进程空间中被分配空间，他们一般不会有这个标志。像代码段、数据段和bss段都会有这个标志位 |
| SHF_EXCINSTR | 4  | 表示该段在进程中可以被执行，一般指代码段                                                                                                                  |

4.  对于系统保留段：

| name      | sh_type      | sh_flag                                                                                                  |
|-----------|--------------|----------------------------------------------------------------------------------------------------------|
| .bss      | SHT_NOBITS   | SHF_ALLOC+SHF_WRITE                                                                                      |
| .comment  | SHT_PROGBITS | nome                                                                                                     |
| .data     | SHT_PROGBITS | SHF_ALLOC+SHF_WRITE                                                                                      |
| .datal    | SHT_PROGBITS | SHF_ALLOC+SHF_WRITE                                                                                      |
| .debug    | SHT_PROGBITS | none                                                                                                     |
| .dynamic  | SHT_DYNAMIC  | SHF_ALLOC+SHF_WRITE 在有些系统下dynamic段可能是只读的，所以没有SHF_WRITE标志位                           |
| .hash     | SHT_HASH     | SHF_ALLOC                                                                                                |
| .line     | SHT_PROGBITS | none                                                                                                     |
| .note     | SHT_NOTE     | none                                                                                                     |
| .rodata   | SHT_PROGBITS | SHF_ALLOC                                                                                                |
| .rodata1  | SHT_PROGBITS | SHF_ALLOC                                                                                                |
| .shstrtab | SHT_STRTAB   | none                                                                                                     |
| .strtab   | SHT_STRTAB   | 如果该ELF文件中有可装载的段必须要用到该字符串表，那么该字符串表也将被装载在进程空间，择优SHF_ALLOC标志位 |
| .symtab   | SHT_SYMTAB   | 同字符串表                                                                                               |
| .text     | SHT_PROGBITS | SHF_ALLOC+SHF_EXECINSTR                                                                                  |

5.  段的链接信息（sh_line、sh_info）：如果段的类型是与链接相关的（无论是动态链接或者是静态链接），比如重定位表、符号表等等。那么sh_link和sh_info两个成员所包含的意义如下所示。对于其他类型的段，这两个成员没有意义

| sh_type     | sh_link                              | sh_info                            |
|-------------|--------------------------------------|------------------------------------|
| SHT_DYNAMIC | 该段所使用的字符串表在段表中的下标   | 0                                  |
| SHT_HASH    | 该段所使用的符号表在段表中的下标     | 0                                  |
| SHT_REL     | 该段所使用的相应符号表在段表中的下标 | 该重定位表所作用的段在段表中的下标 |
| SHT_RELA    |                                      |                                    |
| SHT_SYMTAB  | 操作系统相关                         | 操作系统相关                       |
| SHT_DYNSYM  |                                      |                                    |
| other       | SHN_UNDEF                            | 0                                  |

6.  重定位表

SimpleSection.o有一个叫做“.rel.text”的段，他的类型（sh_type）为“SHT_REL”，也就是说他是一个重定位表（Relocation
Table）链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重重定位的信息都记录在ELF文件的重定位表里面。对于每个需要重定位的代码段或者数据段，都会有一个相应的重定位表

一个重定位表同时也是ELF的一个段，那么这个段的类型（sh_type）就是“SHT_REL”类型的，他的“sh_link”表示符号表的下标，他的“sh_info”表示他作用段那个段。比如“.rel.text”作用于“.text”段，而“.text”段的下标是1，那么“.rel.text”的“sh_info”为1

1.  字符串表

ELF文件中用到了很多字符串，比如段名、变量名等。把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串：

| 偏移 | \+0 | \+1 | \+2 | \+3 | \+4 | \+5 | \+6 | \+7 | \+8 | \+9 |
|------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| \+0  | \\0 | h   | e   | l   | l   | o   | w   | o   | r   | l   |
| \+10 | d   | \\0 | M   | y   | v   | a   | r   | i   | a   | b   |
| \+20 | l   | e   | \\0 |     |     |     |     |     |     |     |

那么偏移与他们对应的字符串表：

| 偏移 | 字符串     |
|------|------------|
| 0    | 空字符串   |
| 1    | helloworld |
| 6    | world      |
| 12   | Myvariable |

常见的段名为“.strtab”或者“.shstrtab”，这两个字符串表分别为字符串表和段表字符串表。字符表用来保存普通的字符串，比如符号的名字；段表字符串表用来保存段表中用过的字符串。最常见的就是段名（sh_name）。e_shstrndx是Elf32_Ehdr的最后一个成员，是“Section
header string table
index”的缩写。段表字符串表本身也是ELF的一个普通的段，名字为“.shstrtab”，那么这个“e_shstrndx”表示“.shstrtab”在段表中的下标，即段表字符串表在段表中的下标。

链接的接口------符号
--------------------

链接过程的本质就是要把多个不同的目标文件之间相互年到一起。在连接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。将函数和变量统称为符号（Symbol），函数名或者变量名，就是符号名（Symbol
Name）

每个目标文件都会有一个相应的符号表（Symbol
Table），这个表里面记录了目标文件中所用到的所有符号，每个定义的符号有一个对应的值，叫做符号值（Symbol
Value），对于变量和函树来说，符号值就是它们的地址。符号表中的符号的类型：

-   定义在本目标文件中的全局符号，可以被其他目标文件引用

-   在本目标文件中引用的全局符号，却没有定义在本目标文件，一般叫做外部符号

-   段名，这种符号旺旺由编译器产生，他的值就是该段的起始地址

-   局部符号，这类符号只在编译单元可见。调试器可以使用这些符号来分析程序或者崩溃时的核心转储文件，这些局部符号对于链接过程没有作用，链接器往往忽略他们

-   行号信息，即目标文件指令与源代码中代码行的对应关系，这是可选的

对于我们来说，最值得关注的是全局符号，即上面的第一类和第二类；局部符号和段名、行号对于其他目标文件是不可见的，在连接中也是无关紧要的。可以使用nm查看符号的使用情况

### ELF符号表的结构

1.  ELF文件中的符号表往往是文件中的一个段，段名一般叫做“.symtab”，符号表的结构很简单，她是一个Elf32_Sym结构（32位ELF文件）的数组，每个Elf32_Sym结构对应一个符号。这个数组的第一个元素，也就是下标0的元素为无效的“未定义”符号。Elf32_Sym的结构定义如下：

typedef struct

{

Elf32_Word st_name;

Elf32_Addr st_value;

Elf32_Word st_size;

unsigned char st_info;

unsigned char st_other;

Elf32_Half st_shndx;

}Elf32_Sym;

| st_name  | 符号名。这个成员包含了该符号名在字符串表中的下标                                                                                  |
|----------|-----------------------------------------------------------------------------------------------------------------------------------|
| st_value | 符号相对应的值，这个值跟符号有关，可能是一个绝对值，也可能是一个地址等等，不同的符号，它所对应的值的含义不同                      |
| st_size  | 符号大小，对于包含数据的符号，这个只是该数据类型的大小。比如double类型的符号占用8个字节。如果该值为0，则表示改符号大小为0或者未知 |
| st_info  | 符号类型和绑定信息                                                                                                                |
| st_other | 该成员目前为0，没用                                                                                                               |
| st_shndx | 符号所在的段                                                                                                                      |

符号的类型和绑定信息（st_info），该成员低4位表示符号的类型（Symbol
Type），高28位表示符号绑定信息（Symbol Binding）

| 符号绑定信息 |    |                                                                                                          |
|--------------|----|----------------------------------------------------------------------------------------------------------|
| 宏定义名     | 值 | 说明                                                                                                     |
| STB_LOCAL    | 0  | 局部符号，对于目标文件的外部不可见                                                                       |
| STB_GLOBAL   | 1  | 全局符号，外部可见                                                                                       |
| STB_WEAK     | 2  | 弱引用                                                                                                   |
| 符号类型     |    |                                                                                                          |
| 宏定义名     | 值 | 说明                                                                                                     |
| STT_NOTYPE   | 0  | 未知类型符号                                                                                             |
| STT_OBJECT   | 1  | 改符号是个数据对象，比如变量，数组等等                                                                   |
| STT_FUNC     | 2  | 该符号是个函数或者其他可执行代码                                                                         |
| STT_SECTION  | 3  | 该符号表示一个段，这种符号必须是STB_LOCAL的                                                              |
| STT_FILE     | 4  | 改符号表示文件名，一般都是该目标所对应的原文件名，他一定是STB_LOCAL类型的，并且它的st_shndx一定是SHN_ABS |

符号所在的段（st_shndx）如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标；如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊：

| 符号所在段特殊常量 |        |                                                                                                                                |
|--------------------|--------|--------------------------------------------------------------------------------------------------------------------------------|
| 宏定义名           | 值     | 说明                                                                                                                           |
| SHN_ABS            | 0xfff1 | 表示该符号包含了一个绝对的值，比如表示文件名的符号就属于这种类型的                                                             |
| SHN_COMMON         | 0xfff2 | 表示改符号是一个“COMMON块”类型的符号，一般来说，未出华的全局符号定义就是这种类型的，比如SimpleSection.o里面的global_uninit_var |
| SHN_UNDEF          | 0      | 表示该符号未定义，这个符号表示改符号在本目标文件被引用到，但是定义在其他目标文件中                                             |

符号值（st_value），如果这个符号是一个函数的变量的定义，那么符号的值就是这个函数或变量的地址

在目标文件中，如果是符号的定义并且改符号不是“COMMON块”类型的，则st_value表示该符号在段中的偏移。即符号所对应的函数或变量位于有st_shndx指定的段，偏移st_value的位置。在可执行文件中，st_value表示符号的虚拟地址

1.  使用readelf:

![](media/585d2e16c0a4baced9ed3d48ed8e2a33.png)

第一列Num表示符号表数组的下标共15个符号；第二列Value就是符号值，即st_value；第三列Size为符号大小，即st_size；第四列和第五列分别为符号类型和绑定信息，即对应st_info的低4位和高28位；第六列VIS目前在C/C++没有使用；第七列Ndx即st_shndx，表示该符号所属的段；当然最后一列是符号名称

1.  printf这个符号，该符号在SimpleSection.c里面被引用，但是没有被定义，所以他的Ndx是SHN_UNDEF

global_init_var是已经初始化的全局变量，他被定义在.bss段，即下标为3

global_uninit_var是未初始化的全局变量，她是一个SHN_COMMON类型的符号，他本身并没有存在于BSS段。

static_var.1533和static_var2.1534是两个静态变量，他们的绑定属性是STB_LOCAL，即只是便一单元内部可见。

那些STT_SECTION 类型的符号，他们表示下标为Ndx的段的段名

上面那个命令，没有显示段名，使用“objdump -t”可以显示段名

### 特殊符号

1.  当我们使用ld作为链接器来链接生成可执行文件时，他会为我们定义很多特殊的符号，这些符号并没有在你的程序中定义，但是你可以直接生命并且引用它，我们称之为特殊符号。这些符号是被定义在ld链接器的连接脚本中。

在其他文件中定义，在本文件中声明并且使用的符号，链接器会在将程序最终连接成可执行文件的时候将其解析成正确的值，只有使用ld链接生成最终的可执行文件的时候这些符号才会存在。几个具有代表性的特殊符号：

-   \__executable_start，该符号为程序起始地址，不是入口地址，是程序的最开始的地址

-   \__etext或者_etext或者etext，该符号为代码段结束地址，即代码段最末尾的地址

-   \_edata或者edata，该符号为数据段结束地址，即数据段最末尾的地址

-   \_end或者end，该符号为程序结束地址

以上地址都为程序被装载是的虚拟地址，我们可以在程序中直接使用这些符号：

![](media/bb504e85a780636d9bf8fb231d97b26c.png)

### 符号修饰与函数签名

1.  UNIX下的C语言规定，C语言源代码文件中的所有全局变量和函数经过编译以后，相对应的符号名钱加上下划线”_”，比如C语言函数”foo”，那么他编译后的符号名就是“_foo”

现在的Linux下的GCC编译器中，默认情况下已经去掉了在C语言符号前面加上“_”的这种方式，但是Windows平台下的编译器还保持这样的传统。GCC编译器可以通过参数选项“-fleading-underscore”或者“-fnoleading-underscore”来打开和关闭是否在C语言符号前面加上下划线

1.  C++符号修饰

两个相同名字的函数func(int)和func(double)，尽管函数名相同，但是参数列表不同，这是C++里面函数重载的最简单的情况，那么编译器和链接器在链接过程中如何区分这两个函数呢？C++发明了符号修饰或者符号改编机制：

int func(int);

float func(float);

class C

{

private:

int func(int);

class C2

{

int func(int);

>   };

};

namespace N

{

int func(int);

class C

{

int func(int);

};

};

这段代码中有6个同名函数叫做func。只不过他们的返回类型和参数及所在的名称空间不同，我们引入一个术语叫做函数签名：包含了一个函数的信息，包括函数名，它的参数类型，他所在的类和名称空间及其他信息。

编译器在将C++源代码编译成目标文件时，会将函数和变量的名字进行修饰，形成符号名

C++编译器和链接器都是用符号来识别和处理函数和变量所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为他们是不同的函数：

| 函数签名              | 修饰后名称（符号名） |
|-----------------------|----------------------|
| int func(int)         | \_Z4funci            |
| float func(float)     | \_Zfuncf             |
| int C::func(int)      | \_ZN1C4funcEi        |
| int C::C2::func(iint) | \_ZN1C2C24funcEi     |
| int N::func(int)      | \_ZN1N4funcEi        |
| int N::C::func(int)   | \_ZN1N1C4funcEi      |

GCC 的基本C++名称修饰方法如下：

所有的符号都以“_Z”开头，对于潜逃的名字（在名称空间或者类里面的），后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，在以“E”结尾。比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。对于一个函数来说，他的参数列表紧跟在“E”后面，对于int类型来说，就是字母“i”。所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi.

1.  binutils里面提供了一个叫“c++filt”的工具可以解析被修饰过的名称，比如：

c++filt \_ZN1N1C4funcEi =\> N::C::func(int)

签名和名称修饰机制不光被使用到函数上，C++中的全局变量和静态变量也有同样的机制。对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制，比如一个名称空间foo中的全局变量bar，他修时候的名字为：_ZN3foo3barE，值得注意的是，变量的类型并没有被加入到修饰后的名称中，所以不论变量是整型还是浮点型，他的名称都是一样的

名称修饰机制也被用来防止静态变量的名字冲突，比如main()函数里面有个静态变量叫做foo，而func()函数里面也有一个静态变量叫做foo。为了区分这两个变量，GCC会将他们的符号名分别秀食城两个不同的名字_ZZ4mainE3foo和_ZZ4funcvE3foo,这样就区分了两个变量

1.  不同的编译器厂商的名称修饰方法不同，见《程序员自我修养》112页

2.  extern “C”

C++为了与C兼容，在符号的管理上，C++有一个用来声明或者定义一个C的符号的“extern
“C””关键字用法：

extern “C”

{

int func(int);

int var;

}

C++编译器会将在“extern
“C””的大括号内部的代码当做C语言代码处理。上面的代码中，C++的名称修饰机制将不会起作用。比如一个C的函数func，定义了一个整型全局变量var，Visual
C++会修饰为：“_func”和”_var”，但是在Linux版本的GCC编译器下，却没有这种修饰，”extern
C”里面的符号都为修饰后符号，即前面不用加上下划线。

如果单独声明某个函数或者变量为C语言的符号，那么也可以使用如下格式：

extern “C” int func(int);

extern “C” int var;

我们做一个小实验：

//ManualNameMangling.cpp

\#include \<stdio.h\>

namespace myname

{

int var = 42;

}

extern “C” int \_ZN6myname3varEi;

int main()

{

printf(“%d\\n”, \_ZN6myname3varEi);

return 0;

}

上述我们按照定义规则，手动的这样声明，得到这个结果：

![](media/acc1dd1a8942ebe1be8ea006100ff1b4.png)

很多时候我们会碰到有些头文件声明了一些C语言的函数和全局变量，但是这个头文件可能会被C语言代码或者C++代码包含。比如很常见的，我们在C语言库函数中的string.h中声明了memset这个函数，他的原型如下：

void \*memset(void\*, int, size_t)

如果不加任何处理，但我们使用C语言程序包含string.h的时候，并且用到了这个函数，编译器会将正确处理，但是在C++中，编译器会将memset的符号修饰成_Z6memsetPvii，这样链接器就无法与C语言库中的memset符号进行连接。所以对于C++来说，必须使用extern
“C”来声明这个函数，但是C语言就不支持这种extern
“C”，如果为了兼容C和C++定义两套头文件，就太麻烦了，我们可以使用C++的宏”__cplusplus”解决该问题。我们可以使用条件宏来判断当前便一单元是不是C++代码：

\#ifdef \__cplusplus

extern “C”

\#endif

void \*memset(void \*, int, size_t);

\#ifdef \__cplusplus

}\#endif

如果当前便一单元是C++代码，那么memset会在extern
“C”里面被声明；如果是C代码，就直接声明，上面这段代码中的技巧几乎在所有的系统头文件被使用到

### 弱符号与强符号

1.  符号重定义

多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候将会初心爱你符号重复定义的错误

1.  对于C/C++语言来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。我们也可以通过GCC的”__attribute__((weak))”来定义任何一个强符号为弱符号。强符号和弱符号都是针对定义来说的，不是针对符号的引用。例如：

extern in text;

int weak;

int strong=1;

\__attribute__((weak)) weak2=2;

int main()

{

return 0;

}

上面这段程序中，“weak”和“weak2”是弱符号，“strong”和“main”是强符号，而“ext”既非强符号也非弱符号，因为它是一个外部变量的引用。针对强弱符号的概念，链接器就会按照如下规则处理与选择被多次定义的全局符号：

-   规则1：不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）；如果出现多个强符号定义，则链接器会报告符号重复定义错误

-   规则2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号

-   规则3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比如目标文件A定义全局变量global为int型，占用4个字节；目标文件B定义global为double型，占用8个字节，那么目标文件A和B链接后，符号global占用8个字节（尽量不要使用多个不同类型的弱符号，否则容易导致很难发现的程序错误）

1.  弱引用和强引用：

目前我们所看到的对外部目标文件的符号引用在目标文件被最终连接成可执行文件时，他们需要被正确决议，如果没有找到该符号的定义，链接器就会报告符号未定义错误，这种被称为强引用

在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报告错误，这是弱引用

两者的区别在于对于未定义弱引用，连接器不认为它是一个错误。一般对于未定义的弱引用，链接器默认其为0，或者是一个特殊的值，一比爱你与程序代码能够识别。弱引用和弱符号主要用于库的链接过程

1.  在GCC中，我们可以通过使用”__attribute__((weakref))”，
    这个扩展关键字来声明一个外部函数的引用为弱引用：

\__attribute_\_ ((weakref)) void foo();

int main()

{

foo();

}

我们将它编译成可执行文件，GCC并不会报告链接错误，但是执行该可执行文件时，会发生运行错误。因为当main函数试图条用foo函数时，foo函数的地址为0，于是发生了非法地址访问的错误，一个改进的例子是：

\__attribute_\_ ((weakref)) void foo();

int main()

{

if(foo)

{

foo();

>   }

}

这种弱符号和弱引用对于库来说十分有用，比如库中定义得弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数；或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；如果我们去掉了某些功能模块，那么程序可以正常连接，只是缺少了相应的功能，这使得程序的功能更加容易剪切和组合

1.  在Linux下，我们可以使用”strip”命令来去掉ELF文件中的调试信息：strip foo

静态链接
========

1.  当我们有两个目标文件时，如何将他们连接起来形成一个可执行文件？这个过程中发生了什么？

>   例子：

| /\*a.c\*/ extern int shared; int main() { int a=100; swap(&a, \&shared); } | /\*b.c\*/ int shared=1; void swap(int \*a, int \*b) { \*a \^= \*b \^= \*a \^= \*b; } |
|----------------------------------------------------------------------------|--------------------------------------------------------------------------------------|


>   经过编译后我们就得到了”a.o”和”b.o”两个目标文件，从代码中可以看到，“b.c”总共定义了两个全局符号：“shared”、“swap”，“a.c”里面引用了“b.c”里面的“shared”、“swap”。接下来要做的事将这两个目标文件链接成一个可执行文件“ab”

空间与地址分配
--------------

1.  对于链接器来说，整个链接过程中，他就是将几个输入目标文件加工后合并成一个输出文件。这么产生了一个问题：对于多个输入目标文件，连接器如何将他们的各个段合并到输出文件？或者说输出文件中的空间如何分配给输入文件？

    1.  按序叠加

2.  一个最简单的反感就是将输入的目标文件按照次序叠加起来：

在有很多输入文件的情况下，输出文件将会有很多零散的段。比如一个规模稍大的应用程序可能会有数百个目标文件，如果每个文件都像上面一样，那最后输出文件将会有成百上千个零散的段。这种做法非常浪费空间，因为每个段都需要有一定的地址和空间对齐要求。对于x86的硬件，段的装载地址空间的对齐单位是页，也就是4096字节。那么就是说如果一个段的长度只有一个字节，他也要在内存中占用4096个字节

### 相似段合并

1.  一个更加实际的方法是将相同性质的段合并到一起：

2.  .bss段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间，所以链接器在合并各个段的同时，也将.bss合并，并且分配虚拟空间。

3.  所谓空间分配到底是什么空间？链接器为目标文件分配地址
    和空间这句话中的“地址和空间”有两个含义：

-   第一个是在输出的可执行文件中的空间

-   第二个是在装载后的虚拟地址中的虚拟地址空间。

>   比如.text和.data来说，他们咋文件中和虚拟地址中都要分配空间；对于.bss这样的段来说，分配空间的意义只局限于虚拟地址空间，因为他在文件中并没有内容

1.  链接器一般采用两步链接的方法：

-   第一步：空间与地址分配
    扫描所有的输入目标文件，并且后的它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，同一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出文件中各个段合并后的长度与位置，并建立映射关系

-   第二步： 符号解析与重定位
    使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址

1.  我们使用ld链接器将“a.o”和“b.o”连接起来：ld a.o b.o –e main –o ab

\-e main表示将main函数作为程序入口，ld链接器默认的程序入口为_start

\-o ab 表示连接输出文件名为ab，默认为a.out

可以使用各个段的属性：

![](media/715e03aace0727c3841d920f9aa80060.png)

![](media/94b39f0729af8425c22f5e10729988cd.png)

VMA表示 Virtual Memory Address即虚拟地址；LMA表示Load Memory
Address即加载地址，从上面我们可以看到，目标文件中的所有段的VMA都是0，因为虚拟空间还没有被分配，所以他们默认是0.可执行文件中的各个段都被分配到了相应的虚拟地址：

Table 目标文件、可执行文件与进程空间简化图

“a.o”和”b.o”的代码被先后叠加起来，合并成一个“ab”的一个“.text”段，加起来长度为0x72,。所以ab的代码段里面肯定包含了main函数和swap函数的指令代码

为什么链接器要讲可执行文件“ab”的“text”分配到0x08048094、将“.data”分配到0x08048108？而不是从虚拟空间的0地址开始分配呢？在LINUX下ELF可执行文件默认从地址0x08048000开始分配

### 符号地址的确定

1.  在第一部的扫描和空间分配阶段，链接器按照前面接受的空间分配方法进行分配这时候输入文件中的各个段在连接后的虚拟地址就已经确定了，比如“.text”段其实地址0x08048094，“.data”段的起始地址为0x08048108

当前面一步完成呢过后，链接器开始计算各个符号的虚拟地址，因为各个符号在段内的相对位置是固定的，所以这时候其实main、shared、和swap的地址也是确定了，只不过链接器需要给每个符号加上一个偏移量，使他们能够调整到正确的虚拟地址

1.  我们假设“a.o”中的main函数相对于“a.o”的“.text”段的偏移是X，但是经过链接合并以后，“a.o”的“.text”段位于虚拟地址0x08048094，那么main的地址应该是0x08048094+X。从前面objdump可以看出，main位于“a.o”的“.text”段的最开始，也就是偏移量为0，所以main这个符号咋最终的输出文件中的地址应该是0x08048094+0。在本文件中各个符号的最终地址：

| 符号   | 类型 | 虚拟地址   |
|--------|------|------------|
| main   | 函数 | 0x08048094 |
| swap   | 函数 | 0x080480c8 |
| shared | 变量 | 0x08048108 |

2.  符号解析与重定位

    1.  重定位

3.  在完成空间和地址的分配步骤后，链接器就进入了符号解析与重定位的步骤，这是静态链接的核心内容。编译器将“a.c”编译成指令时，他如何访问shared变量？如何调用swap函数？使用objdump
    –d看一下a.o的汇编结果：

![](media/d8b1daf56aa32911d352fc6c2de31ce4.png)

在这里我们看到面的其实地址为0x00000000，这是以你为在未进行前面提到过的空间分配之前，目标文件的代码段中的起始地址以0x00000000开始，等到空间分配完后才呢过后，各个函数才会确定自己在虚拟地址空间中的位置

从上图可以看到，main函数占用0x33个字节，工17条指令，最左边那列是没条指令的偏移量，每行带包一条指令（有些指令占用了两行），对于shared和swap：对于shared的引用是一条mov指令，这条指令总公共占用8个字节，它的作用是将share的地址复制到ESP寄存器+4的偏移地址中去，前面4个字节时指令码，后面4个字节时shared的地址：

另外一个偏移为0x26的指令的一条调用指令，他其实就表示swap函数的调用：

图表 1相对地址指令

这条指令5个字节，前免得0xE8是操作码。后面4个字节时别调用函数相对于调用指令的下一条指令的偏移量。在没有重定位之前，相对偏移被置为0xFFFFFFFC(小端)，它是常量-4的补码形式

这条指令的含义：

几根在这条call指令后面的那条指令为add指令，add指令的地址为0x2b，而相对于add指令的偏移为4的地址为0x2b-4=0x27，所以这条call指令的实际调用地址为0x27，所以这条call指令的实际调用地址为0x27，我们可以看到0x27存放着并不是swap函数的地址，跟前面shared的一样，0xFFFFFFFC只是一个临时的假地址，在编译的时候，编译器并不知道swap的真正地址。

编译器把这两条指令的地址暂时用0x00000000和0xFFFFFFFC替代，把真正的地址计算工作留给了链接器

1.  看一下修正后的地址：

![](media/9b1b9d47ae6e63386bab0e43d52cd70b.png)

经过修正后，shared和swap的地址为0x08049108和0x0000000009（小端字节序）。关于shared的地址的确是0x08049108.对于swap，这个call指令是一条进址相对位移调用指令，他后面跟的调用指令的下一条指令的偏移量，call指令的下条指令是add，他的地址为0x080480bf，所以相对于add多指令偏移量为0x00000009的地址为0x080480bf+9=0x080480c8，即刚好是swap函数的地址

### 重定位表

1.  那么链接器是怎么知道哪些指令是要被调整的呢？这些指令的哪些部分要被调整，怎么调整？

2.  重定位表是ELF文件中往往是一个或者多个段。对于可重定位的ELF文件来说，他必须包含有重定位表，用来描述如何修改相应的段里面的内容。对于每个要被重定位的ELF段都有一个对应的重定位表，而一个重定位表往往就是ELF文件汇总的一个段，随意其实重定位表也可以叫做从定位段。比如“.text”如有重定位的地方，那么就有一个“.rel.text”的段保存了代码段的重定位表；如果代码段“.data”有要被重定位的地方，就有一个相对应的叫做“.rel.data”段保存了数据的重定位表。可以使用“objdump
    –r a.o”查看目标文件的重定位表：

![](media/d13b362475cbf126347abf64171df704.png)

这个命令可以用来查看“a.o”里面要重定位的地方。我们可以看到a.o里面有两个重定位的入口。重定位入口的偏移（Offset）表示该入口在要被重定位的段中的位置，“RELOCATION
RECORDS FOR
[.text]”，表示这个重定位表是代码段的重定位表，所以偏移表示代码断种，需要被调整的位置。这里的0x1c、0x27分别就是代码断种“mov”指令和“call”指令的地址部分

1.  重定位表是一个Elf32_Rel结构的数组，每个数组元素对应一个重定位入口：

typedef struct

{

Elf32_Addr r_oofset;

Elf32_Word r_info;

}Elf32_Rel;

| r_offset | 重定位入口的偏移，对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于段起始的偏移，对于可执行文件或者共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址               |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| r_info   | 重定位入口的类型和符号。这个成员的低8位表示重定位入口的类型，搞24位表示重定位入口的符号在符号表的下标 因为各种处理器的指令格式不一样，所以重定位所修正的指令地址格式也不一样，每个处理器都有自己一套重定位入口的类型 |

### 符号解析

1.  重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。比如我们查看a.o的符号表：

![](media/500959165fa66d92136c9e9ed7a4f372.png)

GLOBAL类型的符号，除了main函数定义在代码段之外，其他两个shared和swap都是UND。即为定义类型，这种未定义的符号都是因为该目标文件中有关他们的重定位项。所以在链接器扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报告未定义错误

### 指令修正方式

1.  寻址方式如下几个方面的区别：

-   近址寻址或者远址寻址

-   绝对寻址或者相对寻址

-   寻址长度为8/16/32/64位

但是对于32位x86平台吓得ELF文件的重定位入口所修正的指令寻址方式只有两种：

-   绝对近址32位寻址

-   相对近址32位寻址

>   从定位入口的r_info成员低8位表示重定位入口类型：

| x86基本重定位类型 |    |                 |
|-------------------|----|-----------------|
| 宏定义            | 值 | 重定位修正方法  |
| R_386_32          | 1  | 绝对寻址修正S+A |
| R_386_PC32        | 2  | 相对寻址S+A-P   |

>   A=保存在被修正位置的值

>   P=被修正的位置（相对于段开始的偏移量或者训你地址），注意，该值可通过r_offset计算得到

>   S=符号的实际地址，即由r_info的高24位指定的符号的实际地址

>   现在我们假设将a.o和b.o俩结成最终可执行文件后，main函数的虚拟地址为0x1000，swap函数的虚拟地址为0x2000；shared变量的虚拟地址为0x3000,。那么我们的链接器将如何修正a.o里面这两个重定位入口呢？

-   绝对寻址修正
    看一下a.o文件中偏移为0x18的这条mov指令的修正，他的修正方式是R_386_32，即绝对地址修正，对于这个重定位入口，他修正后的结果应该是S+A

    -   S是符号shared的实际地址即0x3000

    -   A是被修正位置的值，即0x00000000

所以这个重定位入口修正后地址为：0x3000+0x00000000=0x3000，即指令修正后应该是：

![](media/9b0b5288a116b275704bc58e31347c74.png)

-   相对寻址修正
    看一下a.o文件中偏移为0x26的这条call指令的修正，他的指令修正方式是R_386_PC32，他的修正结果为S+A-P

    -   S是符号swap的实际地址，即0x2000

    -   A是被修正位置的值，即0xFFFFFFC(-4)

    -   P
        为被修正的位置，当链接成可执行文件时，这个值应该是被修正的虚拟地址，即0x1000+0x27

所以这个重定位入口修正后地址为：0x2000+（-4）-（0x1000+0x27）=0xFD5，即指令修正后应该是：

![](media/f4fc14f832bd3528403220b47473cf6d.png)

绝对寻址修正和相对寻址修正的区别是绝地寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差

COMMON块
--------

1.  如果一个若符号定义在多个目标文件中，而她们的类型又不同，怎么办？目标前链接器本身并不支持符号的类型，即变量类型对于链接器来说是透明的，他只知道一个符号的名字，并不知道类型是否一致当定义多个符号定义类型不一致时，链接器如何处理？

-   两个或者两个以上强符号类型不一致

-   有一个强符号，其他都是弱符号，出现类型不一致

-   两个或者两个以上弱符号类型不一致

第一种情况无需额外处理，多个强符号定义本身就是非法的，链接器会报告福好多重定义错误

全是弱符号的情况：编译器和链接器都支持一种叫做COMMON块的机制：早起的Fortran没有动态分配空间的机制，程序员必须事先声明他所需要的临时使用空间的大小。当不同的目标文件需要的COMMON块空间不一致时，以最大的那块为准

编译器将未初始化的全局变量定义为弱符号处理，COMMON类型的连接规则是针对符号都是弱符号的情况，如果其中有个符号为强符号，那么最终输出结果中的符号所占空间与强符号相同。如果连接过程中有弱符号大小大于强符号，那么ld链接器会报警告

1.  在目标文件中，编译器为什么把未初始化的全局变量也当做未初始化的局部惊天变量一样处理，为他在BSS段分配空间，而是将其标记为一个COMMON类型的变量

当编译器将一个便一单元编译成目标文件的时候，如果改变一单元包含了弱符号（未初始化的全局变量就是典型的弱符号），那么该弱符号最终所占空间的大小在此时是未知的，因为有可能其他编译单元中该符号所占的空间比本编译单元该符号所占的单元要打。所以编译器此时无法为该弱符号在BSS段分配空间，因为所需大小未知。但是链接器在连接过程中，可以确定弱符号的大小，因为当链接器读取所有输入目标文件后，任何一个弱符号的最终大小都可以确定了，所以他可以在最终输出文件的BSSdaunt为其分配空间，所以总体来看，未初始化全局变量最终还是被放在BSS段。

1.  GCC的“-fno-common”也允许我们把所有未初始化的全局变量不以COMMON块的形式处理，或者使用“__attribute__”扩展：int
    global \__attribute__((nocommon));

一旦一个未初始化的全局变量不是以COMMON块的形式存在，那么他就相当于一个强符号，如果其他目标文件中海油同一个变量的强符号定义，链接器就会报告重复定义的错误

C++相关问题
-----------

1.  C++的一些语言特性使之必须由编译器和链接器共同支持才能完成工作，因为两方面：一是C++的重复代码消除，另一个是全局构造和析构

    1.  C++重复代码消除

2.  C++编译器在很多时候会产生重复代码，比如模板、外部内联函数、虚函数表都可能在不同的便一单元生成相同的代码。当模板在一个便一单元里面被实例化，他并不知道自己是否在背的便一单元也被实例化了。解决的最简单的方案就是不管这些，将这些重复代码都保留下来：

-   空间浪费

-   地址较易出错，有可能两个指向同一个函数的指针会不相等

-   指令运行效率较低，
    因为现代的CPU都会对指令和数据进行缓存，如果同样一份指令有多个副本，那么指令Cache的命中率就会降低

-   一个比较有效的做法就是将每个模板的实例代码都单独地存放在一个段里，每个段值包含一个模板特例比如模板函数是add\<T\>()，某个便一单元以int类型和float类型实例化了这个模板函数，那么该编译单元的目标文件中就包含了两个该模板实例段。我们假设这两个段的名字：.temp.add\<int\>和.temp.add\<float\>。当别的便一单元也以int或者float类型实例化该模板函数后，也会生成同样的名字，这样链接器在最终连接的时候可以区分这些相同的模板实例段，然后将他们合并入最后的代码段。GCC和VISUALC++都采用了类似的方法，GCC把这种类似的需要在最终连接时合并的段叫做“Link
    Once”，他的作坊是将这种类型的段命名为“.gnu.linkonce.name”其中name是该模板函数实例的修饰后名称。VISUALC++还有另外的做法

1.  这种重复代码消除对于疤来说是这样的，对于外部内联函数和虚函数表的做法也累死，比如对于一个有虚函数的类来说，有一个虚函数表。编译器会在用到该类的多个便一单元生成虚函数表，造成代码重复；外部内联函数、默认构造函数、磨人拷贝函数和复制操作符也有类似的问题。他们的解决方式基本跟模板的重复代码消除相似。这种方法虽然能够基本解决代码重复的问题，但是还存在一些问题。比如相同名称的段可能拥有不同的内容，这可能由于不同的便一单元是用了不同的编译器版本或者便已优化选项。导致同一个函数编译出来的实际代码有所不同，那么这种情况下链接器可能会做出一个选择，那就是随意选择其中任何一个副本作为链接的输入，同时输出一个警告信息

2.  函数级别的连接

一个目标文件中可能包含成千上百个函数或者变量，当我们需要用到某个目标文件中的任意一个函数或者变量时，就需要把整个地连接起来，也就是说那些没有用到的函数也被连接起来。VISUALC++编译器体用了一个编译选项叫做函数级别连接。这个选项的作用就是让所有的函数都想前面模板函数一样，单独保存在一个段里面，当连机器需要用到某个函数时，就将它合并到输出文件中，对于那些没有用到的函数抛弃。GCC编译器也提供了类似的机制，它有两个选择分别是：-ffunction-sections和-fdata-sections，这两个选项的作用就是将每个函数或变量分别保持到独立的段中

### 全局构造和析构

1.  在main函数被调用之前，为了程序能够顺利进行，要先初始化进程执行环境，比如对分配初始化化（malloc、free）、线程子系统等等。C++全局对象构造函数是在main执行之前执行的，C++全局对象的析构函数在main之后执行

2.  LINUX系统下一般程序的入口是“_start”，这个函数是Linux系统库（Glibc）的一部分。这个函数就是程序的初始化部分的入口。程序初始化部分完成一系列初始化过程之后，会调用main函数来执行程序的主体，在main函数执行完成
    以后，返回到初始化部分，他进行一些清理工作，然后结束进程

3.  C++存在两种特殊的段

-   .init
    该段里面保存的是可执行指令，它构成了进程的初始化代码。在main函数被调用之前，Glibc的初始化部分安排执行这个段中的代码

-   .fini
    该段保存着进程终止代码指令。当一个程序的main函数正常退出时，Glibc会安排执行这个段中的代码

    1.  C++与ABI

有没有不同编译器编译出来的目标文件是不能够相互连接的？有没有可能将MSVCX编译出来的目标文件和GCC编译出来的目标文件连接到一起，形成一个可执行文件呢？如果要将两个不同编译器的编译结果链接到一起。首先链接器必须支持这两种编译器产生的目标文件的格式。链接器必须同时认识这两种格式才行，否则肯定不行。那是不是链接器只要同时认识目标文件的格式就可以了？如果要是两个编译器编译出来的目标文件能够相互连接，那么这两个目标文件必须满足下面条件：

-   采用同样的目标文件格式

-   拥有同样的符号修饰标准

-   变量的内存分布方式相同

-   函数的调用方式相同

-   等等

把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制金融性相关的内容成为ABI（Application
Binary Interface）

API是指源代码级别的接口，ABI兼容程度比API更为严格，比如我们可以说C++的兑现内存分布是C++ABI的一部分。

1.  对于C语言的目标代码来说，一下几个方面会决定目标文件之是否二进制兼容：

-   内置类型（如int、char）的大小和在存储器中的放置方式（大小端、对齐方式等等）

-   组合类型（如struct /union/数组等等）的存储方式和内存分布

-   外部符号与用户定义的符号之间的命名方式和解析方式，如函数func在C的目标文件中是否被解析城外部符号_func

-   函数的调用方式，比如参数入栈顺序、返回值如何保持等

-   堆栈的分布方式，比如参数和局部变量在堆栈的位置，参数传递方法等等

-   寄存器使用约定，函数嗲用是哪些寄存器可以修改，哪些需要保存等等

这只是一部分因素。到了C++时代，语言层面对ABI的影响又增加了很多额外内容：

-   继承类体系的内存分布如基类、虚基类在继承中的位置。

-   指向成员函数的指针的内存分布，如何通过执行成员函数的指针来调用成员函数，如果传递this指针

-   如何调用虚函数，vtable的内容和分布形式，vtable指针在object中的位置等等

-   template如何实例化

-   外部符号的修饰

-   全局对象的构造和析构

-   异常的产生和捕获机制

-   标准库的细节问题，RTTI如果实现等等

-   内嵌函数访问细节

    1.  静态库链接

1.  使用“-fno-builtin”参数，GCC会关闭内置函数优化项。比如在C程序中，会默认使用puts代替printf，提高运行速度。使用-verbose将真个编译链接过程的中间步骤打印出来，会发现collect2.collect2可以看做ld链接器的一个包装，它会嗲用ld链接器来完成对目标文件的链接，然后再对链接结果进行一些处理，抓哟是手机所有与程序初始化相关的信息并且构造初始化的结构

    1.  链接过程控制

2.  整个链接过程有很多内容需要确定：使用那些目标文件？使用哪些库文件？是否在最终可执行文件中保留调试信息、输出文件格式（可执行文件还是动态链接库）？是否要到处某些符号以供调试器或者程序本身或者其他程序使用？

可执行文件的装载与进程
======================

1.  可执行文件只有装载到内存之后才能被CPU执行

2.  什么是进程的虚拟地址空间？为什么进程要有自己独立的虚拟地址空间？

    1.  进程虚拟地址空间

3.  程序（或者狭义上将可执行文件）是一个静态的概念，他就是一些预先编译好的指令和数据集合的一个文件；进程则是一个动态的概念，她是程序运行时的一个过程。

4.  每个程序被运行起来以后，他将拥有自己独立的虚拟地址空间，这个虚拟地址空间的大小由计算机的硬件平台决定，具体来说是由CPU的位数决定的。硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如22位的硬件平台决定了虚拟地址看空间为0\~232
    -1，即0x00000000\~0xFFFFFFFF，也就是4G虚拟空间大小；而64位的硬件平台具有64位寻址能力，他的虚拟地址空间达到了264字节，即0x00000000000000000\~0xFFFFFFFFFFFFFFFF，总共17179869184G。

5.  C语言指针的大小的位数和虚拟地址空间的位数相同，如32为平台下的指针32位，即4字节；68位平台下的指针为64位，即8字节

6.  尽管电脑可能有4G的内存，但是并不能任意使用。所有的代码、数据包括通过C语言malloc()等方法申请的虚拟空间之和不可以超过3G。令人遗憾的是，进程并不能完全使用3G的虚拟空间，其中一部分是预留给其他用途的

7.  从硬件层面上来讲，原先的32位地址线只能访问最多4G的物理内存。但是自从扩展到36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存。Intel将这种地址扩展方式叫做PAE（Physical
    Address Extension）

8.  一个很常见的方法就是操作系统提供一个窗口映射的方法，把这些额外的内存映射到进程地址空间中来。应用程序可以根据需要来选择申请和映射，比如一个应用程序中0x10000000\~0x20000000这一段256M的虚拟地址空间用来做窗口，程序可以从高于4G的物理空间中申请多个大小为256M的物理空间，编号为A、B、C等等，然后根据需要将这些窗口映射到不同的物理空间快，用到A时将0x10000000\~0x20000000映射到A，用到B、C时在映射过去，若此重复操作。在Windows下，这种警方问内存的操作方式叫做AWE（Addree
    Windowing Extensions）；而像Linux等Unix类操作系统采用mmap()系统调用来实现

    1.  装载的方式

9.  程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程序运行所需要的指令和数据全部装载内存中，这样程序可以顺利运行，这就是最简单的静态装入的办法。很多情况下程序所需要的内存数量大于物理内存的数量，担当内存的数量不够时，根本解决办法就是添加内存。

10. 程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不态常用的数据存放在磁盘里面，这就是动态装入的基本原理。覆盖装入和也映射是两种很典型的动态装在方法，这两种方法原则上都是利用了程序的局部性原理。动态装入的思想史程序用到哪个模块，将讲哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中

    1.  覆盖装入

11. 覆盖装入在没有发明虚拟存储之前使用比较广泛，现在几乎已经淘汰了。覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工匠程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉。这个小的辅助代码就是所谓的覆盖管理器。最简单的情况下，一个程序有主模块main，main会嗲用模块A和模块B，但是A和B之间不会相互调用，这三个模块的大小分别为1024字节、512字节，256字节。假设不考虑内存对齐，装载地址限制，理论上运行这个程序需要有1792个字节的内存，如果我们采用覆盖装入：

由于模块A和模块B之间相互调用关系，我们可以把模块A和模块B在内存中相互覆盖。即两个模块共享内存区域。当面模块调用模块A时，覆盖管理器保证将模块A从文件中读入内存；当模块main调用模块B时，则覆盖管理器将模块B从文件中读入内存，由于这时候模块A不会被使用，那么模块B可以装入到原来模块A所占用的内存空间。很明显，除了覆盖管理器，真个程序运行只需要1536个字节，节省了256个字节。覆盖管理器本身很小，从数十字节到数百字节不等，一般常驻内存。

上面的情况比较简单，在多个模块下，程序员需要手工将模块按照他们之间的调用依赖关系组织成树状结构。模块main依赖于模块A和B，模块A依赖于C和D；模块B依赖于E和F，则他们再内存中的覆盖方式如下：

![](media/1cfc87fa7bcfc95025a24260bea61c74.emf)

这个树状结构中从任何一个模块到树的跟（也就是main）模块都叫调用路径，当该模块被调用时，整个调用路径上的模块必须都在内存中。比如程序正在模块E中执行代码，那么模块B和模块main比需都在内存中，以确保模块E执行完毕以后能够正确返回至模块B和模块main。任何跨树间调用。任意一个模块不允许跨过树状结构进行调用。比如上面例子中，模块A不可以调用模块B、E、F；模块C不可以调用模块D、B、E、F等，因为覆盖管理器不能够保证跨树间的模块能够存在于内存中。不过很多时候可能两个子模块都需要依赖于某个模块，比如模块E和模块C都需要另外一个模块G，最方便的做法是将模块G并入到main模块中，这样G就在E和C的调用路径上。

由于扩模块的调用都需要经过覆盖管理器，以确保所有被调用到的模块都能够正确地驻留在内存，而且一旦模块没有在
内存中，还需要从磁盘或者其他存储器读取相应德玛欧快，所以覆盖装入的速度肯定比较慢，不过这是个折中的办法

### 页映射

1.  页映射是虚拟存储机制一部分。页映射也不是一下子就把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令按照“页”为单位划分成若干个页，以后所有的装载和操作的单位就是页。

2.  目前的情况，硬件规定的页的大小有4096字节、8192字节、2MB、4MB等等，最常见的Intel
    IA32处理器一般都是用4096字节的页，那么512MB的物理内存就拥有512\*1024\*1024/4096=131072页。

3.  为了演示页映射的基本机制，假设我们的32位机器有16KB的内存，每个页大小为4096字节，则共有4个页

如下所示：

| 页编号 |                        |
|--------|------------------------|
| F0     | 0x00000000\~0x00000FFF |
| F1     | 0x00001000\~0x00001FFF |
| F2     | 0x00002000\~0x00002FFF |
| F3     | 0x00003000\~0x00003FFF |

假设程序所有的指令和数据总和为32KB，那么程序总共被分为8个页。编号为P0\~P7。16KB的内存无法同时将32KB程序装入。按照动态装入的原理装入。如果程序刚开始执行时的入口地址在P0，这是装载管理器（像覆盖管理器）发现程序的P0不在内存中，于是将内存F0分配到P0，并且将P0的内存装入F0；运行一段时间以后，程序需要用到P5，于是装载管理器将P5装入F1；当程序用到P3和P6的时候，他们分别被装入到了F2和F3，映射关系：

如果这时候程序只需要P0、P3、P5和P6这4个页，那么程序就能一直运行下去，但是问题出现了，如果这时候程序需要访问到P4，那么装载管理器必须放弃目前正在使用的4个内存页中的其中一个来装载P4，至于选择哪个页，我们有多重算法可以选择，可以选择F0，因为他是第一恶被分配掉的内存页（这个算法是FIFO）；假设装载管理器发现F2很少被访问到，那么我们可以选择F2（这种算法为LUR）。假设我们放弃P0，F0将装入P4。这就是说为的装载管理器就是现代的操作系统，更加准确地讲就是操作系统的存储管理器。Windows对PE文件的装载及Linux对ELF文件的装载都是这样完成的。

从操作系统角度看可执行文件的装载
--------------------------------

1.  从页映射的动态装入的方式可以看到，可执行文件中的页可能被装入内存中的任意页。比如程序需要P4的时候，他可能会被装入F0\~F3这4个页的任意一个。很明显，如果程序使用物理地址直接进行操作，那么每次页被装入时都需要进行重定位。现代的硬件MMU提供地址转换功能。有了硬件的地址转换和页映射机制，操作系统冬天加载可执行文件的方式跟静态加载有了很大的区别

    1.  经常的建立

2.  从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得他有别于其他进程。很多时候一个程序被执行的同时都伴随一个新的进程的创建：创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟存储的情况下，下属过程最开始只需要做三件事情：

-   创建一个独立的虚拟地址空间

-   读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系

-   将CPU的指令寄存器设置成可执行文件的入口地址，启动运行

-   首先是创建虚拟地址空间。一个虚拟地址空间由一组也映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录。甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置

-   读取可执行文件头，并且建立虚拟空间与可执行文件的以你干涉关系。也映射关系函数是虚拟空间到物理内存的映射关系
    这一步所做的是虚拟空间与可执行文件的映射关系。当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该缺页从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序裁得已正常运行。

>   当操作系统捕获到缺页错误时，他应该知道程序当前所需要的页在可执行文件中的
>   哪一个位置，虚拟空间与可执行文件之间的映射关系。由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被称为映像文件。

-   操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址。还记得ELF文件头中保存有入口地址吗？没错，就是这个地址。

1.  假设我们的ELF可执行文件只有一个代码段“.text”，他的虚拟地址为0x08048000，它在文件中的大小为0x000e1，对齐为0x1000.由于虚拟存储的页映射都是以页为单位的，在32位Intel
    IA32下一班为4096字节，所以32为ELF的对其粒度为0x1000.由于该.text段大小不到一个页，考虑到对齐该段占用一个段。所以一旦该可执行文件被装载，可执行文件与执行该可执行文件进程的虚拟空间的映射关系：

>   这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA）；在Windows中将这个叫做虚拟段。操作系统创建进程后，会在进程相应的数据结构中设置有一个.text段的VMA：它在虚拟空间中的地址为0x08048000\~0x08049000,它对应ELF文件中便宜为0的.text，它的属性为只读，还有一些其他的属性

1.  操作系统在内部存在这种结构，很明显是因为当程序执行发生段错误时，他可以通过查找这样的一个数据结构来定位错误页在可执行文件中的位置。将CPU指令此存器设置成可执行文件入口，启动运行。

    1.  页错误

2.  上面的步骤执行完成后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。例子中，程序的入口地址为0x08048000，即刚好是.text段的起始地址。当CPU开始打算执行这个地址的指令时，发现页面0x08048000\~0x08049000是个空页面，于是他就认为这是一个页错误。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。这时候我们前面提到的装在过程的第二步建立的数据结构起到了关键作用，操作系统将查询这个数据结构，然后找到空页面所在的VMA，计算出相应的页面咋IE可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行

3.  随着进程的执行，页错误约会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求，如下图：

淡然有可能进程所需要的内存会超过可用的内存数量，特别是在有多个进程所需要的内存是执行的时候，这时候操作系统就需要精心组织和分配物理内存，甚至有时候应将分配给进程的物理内存暂时收回等等，这就涉及了操作系统的虚拟存储管理

1.  进程虚存空间分布

    1.  ELF文件链接试图和执行视图

2.  ELF文件被映射时，是以系统的页长度作为单位的，每个段在映射时的长度应该都是系统页长度的整数倍；如果不是那么多余部分也将占用一个页。这会造成内存浪费。有没有办法减少这种内存浪费呢？

站在操作系统装载可执行文件的角度，可以发现它实际上并不关心可执行文件各个段所包含的实际内容，操作系统只关心一些跟装载相关的问题，最主要的是段的权限。ELF文件中，段的权限往往只有为数不多的几种组合：

-   以代码段尾代表的权限为可读可执行的段

-   以数据段和BSS段为代表的可读可写的段

-   以只读数据段为代表的只读的段

那么很简单的一个方案就是：对于相同权限的段，我们把它合并到一起当做一个段进行映射。比如”.text”和“.init”，权限都为可读可执行。假设“.text”和“.init”分别为4097个字节和512字节，如果按照内存浪费的那种情况，需要三个页面。但是合并到一起映射的话只需要两个页面：

1.  Elf
    可执行文件引入了一个概念叫做“Segment”，一个“Segment”包含一个或多个属性类似的“Section“。将”.text“和”.init“一块映射，只需要两个Page。

2.  Segment的概念实际上是从装载的角度重新划分了ELF的各个段。再将目标文件连接成可执行文件的时候，链接器会尽量把相同权限属性的段分配在同一空间。比如可读可执行的段都放在一起，这种段的典型是数据段。在ELF中把这些属性相似的、有链接在一起的段叫做Segment。系统按照Segment而不是按照Section映射的

3.  代码：

\#include \<stdlib.h\>

int main()

{

while(1)

{

sleep(1000);

}

return 0;

}

使用gcc –static SectionMapping.c –o SectionMapping.elf

![](media/da007a1ea1a46c1ff4f4f8b9df4952ef.png)

![](media/20177653474e23487b966f5b1362fb6e.png)

描述Segment的结构叫做程序头。他描述了ELF文件该如何被操作系统映射到进程的虚拟空间：

![](media/012d799fa734279e0fa8a4c4c159dd59.png)

从装载的角度看，目前我们只关心两个“LOAD”类型的Segment，因为只有他是需要被映射的，其他的诸如NOTE、TLS、GNU_STACK都是在装载时起辅助作用。

SectionMapping.elf被重新划为三部分：

-   有一些段被归入可读可执行的，他们被统一映射到一个VMA0；

-   另外一部分是可读可写的，他们被映射到VMA1；

-   一部分段咋程序装载时没有被映射的，他们是一些包含调试信息和字符串表等段，这些段在程序执行时没有用，所以不需要被映射

Segment和Section是从不同的角度来划分同一个ELF文件。这个ELF中被称为不同的视图。从Section角度来看ELF文件时链接试图；从Segment的角度来看就是执行视图

Figure ELF可执行文件与进程虚拟空间映射关系

1.  ELF可证性文件中有一个专门的数据结构叫做程序表用来保存Segment的信息。因为ELF目标文件不需要被装在，所以没有程序头表，而ELF的可执行文件和共享库文件都有，程序头表也是一种结构体数组：

typedef struct

{

Elf32_Word p_type;

Elf32_Off p_offset;

Elf32_Addr p_vaddr;

Elf32_Addr p_paddr;

Elf32_Word p_filesz;

Elf32_Word p_memsz;

Elf32_Word p_flags;

Elf32_Word p_align;

}Elf32_Phdr;
